<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classic Pong Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Lesson Learned II.3: Disable panning/zooming for clean touch interactions */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117;
            display: flex;
            flex-direction: column;
            justify-content: center; /* Vertically center the container */
            align-items: center;     /* Horizontally center the container */
            min-height: 100vh;
            overflow: hidden;
            touch-action: none; 
        }
        #game-container {
            /* Aggressive Vertical Fix: Reduced max-height for console stability */
            @apply flex flex-col justify-start items-center p-4 rounded-xl shadow-2xl;
            background-color: #1a202c;
            border: 8px solid #3b82f6;
            max-width: 95vw;
            width: 95%; /* Use fluid width */
            max-height: 65vh; /* Further reduction for console stability */
            height: 100%; 
            box-sizing: border-box;
            position: relative; 
        }
        #pongCanvas {
            background-color: #000;
            display: block;
            flex-grow: 0; 
            margin: 0 auto; /* CRITICAL: Ensure the canvas is horizontally centered as a flex item */
            border-radius: 4px;
        }
        .message-box {
            /* Ensures message box fills the container exactly */
            @apply absolute inset-0 bg-gray-900 bg-opacity-95 flex flex-col justify-center items-center text-white p-4 rounded-md cursor-pointer;
            z-index: 100;
            height: 100%; 
            width: 100%;
            box-sizing: border-box;
            border-radius: 4px;
        }
        .start-button {
            /* Compact button style - this button is now just a visual element */
            @apply mt-4 px-6 py-2 bg-green-500 text-black font-bold text-base rounded-full shadow-lg hover:bg-green-400 transition transform hover:scale-105;
            pointer-events: none; /* Disable its own click so the parent message-box handles it */
        }
        #game-title {
            /* Fix Title Wrapping: Reduced font size */
            @apply text-2xl font-extrabold text-white mb-4;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <!-- Title with reduced font size -->
        <h1 id="game-title">PONG CLASSIC</h1>
        
        <!-- The Canvas -->
        <canvas id="pongCanvas"></canvas>
        
        <!-- Score Display -->
        <div id="score-display" class="mt-4 text-xl font-mono text-white">PLAYER: 0 | CPU: 0</div>
    </div>

    <script>
        // --- Canvas Setup and Game Variables ---
        const canvas = document.getElementById('pongCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score-display');
        const container = document.getElementById('game-container');
        
        // Game Dimensions (Internal Drawing Resolution - 4:3 Aspect Ratio)
        const GAME_WIDTH = 400;
        const GAME_HEIGHT = 600;
        let scaleFactor = 1;

        // Paddles
        const PADDLE_WIDTH = 10;
        const PADDLE_HEIGHT = 70;
        let playerY = (GAME_HEIGHT / 2) - (PADDLE_HEIGHT / 2);
        let cpuY = (GAME_HEIGHT / 2) - (PADDLE_HEIGHT / 2);
        const PADDLE_SPEED = 6;

        // Ball
        const BALL_SIZE = 10;
        let ballX = GAME_WIDTH / 2;
        let ballY = GAME_HEIGHT / 2;
        let ballSpeedX = 5;
        let ballSpeedY = 5;

        // Game State
        let playerScore = 0;
        let cpuScore = 0;
        const WINNING_SCORE = 5; // <-- Confirmed: First to 5 wins!
        let gameRunning = false;
        let gameOver = false;

        // --- Core Game Logic (Drawing, Movement, Collision) ---

        function drawRect(x, y, w, h, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x, y, w, h);
        }

        function drawCircle(x, y, r, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2, false);
            ctx.closePath();
            ctx.fill();
        }

        function drawNet() {
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.setLineDash([10, 10]);
            ctx.moveTo(GAME_WIDTH / 2, 0);
            ctx.lineTo(GAME_WIDTH / 2, GAME_HEIGHT);
            ctx.stroke();
        }

        function drawScores() {
            scoreDisplay.textContent = `PLAYER: ${playerScore} | CPU: ${cpuScore}`;
        }

        function drawEverything() {
            // Background
            drawRect(0, 0, GAME_WIDTH, GAME_HEIGHT, '#000');
            drawNet();
            drawRect(GAME_WIDTH - PADDLE_WIDTH - 20, playerY, PADDLE_WIDTH, PADDLE_HEIGHT, '#10b981'); 
            drawRect(20, cpuY, PADDLE_WIDTH, PADDLE_HEIGHT, '#3b82f6'); 
            drawCircle(ballX, ballY, BALL_SIZE / 2, '#ef4444');
        }

        function moveBall() {
            ballX += ballSpeedX;
            ballY += ballSpeedY;

            if (ballY < BALL_SIZE / 2 || ballY > GAME_HEIGHT - BALL_SIZE / 2) {
                ballSpeedY = -ballSpeedY;
            }
        }

        function resetBall(servingPlayer) {
            ballX = GAME_WIDTH / 2;
            ballY = GAME_HEIGHT / 2;
            // The ball direction is decided by who scored the last point
            ballSpeedX = servingPlayer === 'player' ? -5 : 5;
            ballSpeedY = Math.random() > 0.5 ? 5 : -5;
        }
        
        function computerMovement() {
            const cpuCenter = cpuY + PADDLE_HEIGHT / 2;
            // Simple AI that tracks the ball but lags a bit (0.7 speed)
            if (cpuCenter < ballY - 20) {
                cpuY += PADDLE_SPEED * 0.7;
            } else if (cpuCenter > ballY + 20) {
                cpuY -= PADDLE_SPEED * 0.7;
            }
            if (cpuY < 0) cpuY = 0;
            if (cpuY > GAME_HEIGHT - PADDLE_HEIGHT) cpuY = GAME_HEIGHT - PADDLE_HEIGHT;
        }

        function checkCollision() {
            const playerX = GAME_WIDTH - PADDLE_WIDTH - 20;

            // Player Paddle Collision (right side)
            if (ballX > playerX - BALL_SIZE / 2 && ballX < playerX + PADDLE_WIDTH + BALL_SIZE / 2 && 
                ballY > playerY && ballY < playerY + PADDLE_HEIGHT) 
            {
                ballSpeedX = -ballSpeedX;
            } 
            
            const cpuX = 20;
            // CPU Paddle Collision (left side)
            if (ballX < cpuX + PADDLE_WIDTH + BALL_SIZE / 2 && ballX > cpuX - BALL_SIZE / 2 &&
                ballY > cpuY && ballY < cpuY + PADDLE_HEIGHT)
            {
                ballSpeedX = -ballSpeedX;
            }

            // Scoring
            if (ballX < BALL_SIZE / 2) { // CPU scores
                playerScore++;
                checkWinCondition();
                resetBall('cpu'); 
            } else if (ballX > GAME_WIDTH - BALL_SIZE / 2) { // Player scores
                cpuScore++;
                checkWinCondition();
                resetBall('player'); 
            }
        }

        function checkWinCondition() {
            if (playerScore >= WINNING_SCORE) {
                gameOver = true;
                displayMessage('You Won!', 'Congratulations! Tap anywhere to restart.', startGame);
            } else if (cpuScore >= WINNING_SCORE) {
                gameOver = true;
                displayMessage('You Lost!', 'Better luck next time. Tap anywhere to restart.', startGame);
            }
        }

        function gameLoop() {
            if (!gameRunning || gameOver) return;
            moveBall();
            computerMovement();
            checkCollision();
            drawEverything();
            drawScores();
            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            playerScore = 0;
            cpuScore = 0;
            gameOver = false;
            gameRunning = true;
            resetBall('player');
            drawScores();
            gameLoop();
        }
        
        function displayMessage(title, text, action) {
            gameRunning = false;
            const existingMessage = document.getElementById('game-message');
            if (existingMessage) existingMessage.remove();

            const messageBox = document.createElement('div');
            messageBox.id = 'game-message';
            messageBox.className = 'message-box';
            
            messageBox.innerHTML = `
                <h2 class="text-3xl font-extrabold mb-3 text-yellow-400 text-center">${title}</h2>
                <p class="text-sm mb-4 text-center px-2">${text}</p>
                <button class="start-button">
                    TAP TO START
                </button>
            `;
            container.appendChild(messageBox);
            
            const startHandler = (e) => {
                e.stopPropagation(); 
                messageBox.removeEventListener('click', startHandler);
                messageBox.removeEventListener('touchstart', startHandler);
                action();
            };

            messageBox.addEventListener('click', startHandler);
            messageBox.addEventListener('touchstart', startHandler);
        }


        // --- Responsiveness and Input Handling ---

        function handleResize() {
            // Set internal drawing size
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;

            // Step 1: Calculate the total vertical space taken up by non-canvas elements
            const overheadTop = canvas.offsetTop; 
            
            // Step 2: Calculate the height of elements below the canvas (score + its margin)
            const overheadBottom = scoreDisplay.getBoundingClientRect().height + 20; 
            
            // Step 3: Calculate the available height for the canvas
            const availableHeight = container.clientHeight - overheadTop - overheadBottom;
            const availableWidth = container.clientWidth - 32; // Container width minus horizontal padding (p-4 * 2 = 32px)

            // Step 4: Determine the scale factor based on the smaller dimension (the constraint)
            const scaleX = availableWidth / GAME_WIDTH;
            const scaleY = availableHeight / GAME_HEIGHT;
            
            scaleFactor = Math.min(scaleX, scaleY);
            
            // Step 5: Apply the calculated external dimensions to the canvas style
            const finalWidth = GAME_WIDTH * scaleFactor;
            const finalHeight = GAME_HEIGHT * scaleFactor;
            
            canvas.style.width = `${finalWidth}px`;
            canvas.style.height = `${finalHeight}px`;

            drawEverything();
            drawScores();
        }

        // Mouse/Touch Input Handler
        function handlePaddleMove(e) {
            if (!gameRunning || gameOver) return;
            e.preventDefault(); 
            
            let clientY = 0;
            if (e.touches && e.touches.length > 0) {
                clientY = e.touches[0].clientY;
            } else if (e.clientY !== undefined) {
                clientY = e.clientY;
            } else {
                return;
            }

            const canvasRect = canvas.getBoundingClientRect();
            // Calculate position within the internal canvas drawing coordinates
            const touchY = (clientY - canvasRect.top) / scaleFactor;
            const newPlayerY = touchY - (PADDLE_HEIGHT / 2);
            
            playerY = Math.max(0, Math.min(GAME_HEIGHT - PADDLE_HEIGHT, newPlayerY));
        }

        // Attach listeners
        window.addEventListener('resize', handleResize);
        window.addEventListener('load', () => {
            setTimeout(() => {
                handleResize();
                displayMessage('Welcome to Pong!', 'Drag the green paddle (right) up and down to play. First to 5 points wins! Tap anywhere to begin!', startGame);
            }, 100);
        });

        canvas.addEventListener('mousemove', handlePaddleMove);
        canvas.addEventListener('touchmove', handlePaddleMove);
        canvas.addEventListener('touchstart', (e) => {
            handlePaddleMove(e);
            e.preventDefault();
        });

    </script>
</body>
</html>
