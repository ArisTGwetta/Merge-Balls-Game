<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classic Pong Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            touch-action: none; /* Disable panning/zooming */
        }
        #game-container {
            /* Applying Lesson Learned I.1: use less than 100vh */
            @apply flex flex-col justify-center items-center p-4 rounded-xl shadow-2xl;
            background-color: #1a202c;
            border: 8px solid #3b82f6;
            max-width: 90vw;
            width: 400px;
            /* Height will be managed by JS to maintain 4:3 aspect ratio */
        }
        canvas {
            background-color: #000;
            display: block;
            /* Applying Lesson Learned I.2: Prevent stretching */
            flex-grow: 0;
            margin: auto;
            border-radius: 4px;
        }
        .message-box {
            @apply absolute inset-0 bg-gray-900 bg-opacity-90 flex flex-col justify-center items-center text-white p-4 rounded-md;
            z-index: 100;
        }
        .start-button {
            @apply mt-6 px-8 py-3 bg-green-500 text-black font-bold text-lg rounded-full shadow-lg hover:bg-green-400 transition transform hover:scale-105;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <h1 class="text-3xl font-extrabold text-white mb-4">PONG CLASSIC</h1>
        <canvas id="pongCanvas"></canvas>
        <div id="score-display" class="mt-4 text-xl font-mono text-white">PLAYER: 0 | CPU: 0</div>

        <!-- Touch Controls for Mobile -->
        <div id="touch-area" class="w-full h-8 flex justify-center items-center mt-4 bg-gray-800 rounded-lg text-gray-400 text-sm">
            Drag finger left/right on the canvas to control the paddle.
        </div>
    </div>

    <script>
        // --- Canvas Setup and Game Variables ---
        const canvas = document.getElementById('pongCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score-display');
        const container = document.getElementById('game-container');

        // Game Dimensions (Internal Drawing Resolution - 4:3 Aspect Ratio)
        const GAME_WIDTH = 400;
        const GAME_HEIGHT = 600;
        let scaleFactor = 1;

        // Paddles
        const PADDLE_WIDTH = 10;
        const PADDLE_HEIGHT = 70;
        let playerY = (GAME_HEIGHT / 2) - (PADDLE_HEIGHT / 2);
        let cpuY = (GAME_HEIGHT / 2) - (PADDLE_HEIGHT / 2);
        const PADDLE_SPEED = 6;

        // Ball
        const BALL_SIZE = 10;
        let ballX = GAME_WIDTH / 2;
        let ballY = GAME_HEIGHT / 2;
        let ballSpeedX = 5;
        let ballSpeedY = 5;

        // Game State
        let playerScore = 0;
        let cpuScore = 0;
        const WINNING_SCORE = 5;
        let gameRunning = false;
        let gameOver = false;

        // --- Core Functions ---

        function drawRect(x, y, w, h, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x, y, w, h);
        }

        function drawCircle(x, y, r, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2, false);
            ctx.closePath();
            ctx.fill();
        }

        function drawNet() {
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.setLineDash([10, 10]);
            ctx.moveTo(GAME_WIDTH / 2, 0);
            ctx.lineTo(GAME_WIDTH / 2, GAME_HEIGHT);
            ctx.stroke();
        }

        function drawScores() {
            scoreDisplay.textContent = `PLAYER: ${playerScore} | CPU: ${cpuScore}`;
        }

        function drawEverything() {
            // Background
            drawRect(0, 0, GAME_WIDTH, GAME_HEIGHT, '#000');

            // Net
            drawNet();

            // Paddles (Player is on the right for easier mobile drag)
            drawRect(GAME_WIDTH - PADDLE_WIDTH - 20, playerY, PADDLE_WIDTH, PADDLE_HEIGHT, '#10b981'); // Player (Right)
            drawRect(20, cpuY, PADDLE_WIDTH, PADDLE_HEIGHT, '#3b82f6'); // CPU (Left)

            // Ball
            drawCircle(ballX, ballY, BALL_SIZE / 2, '#ef4444');
        }

        function moveBall() {
            ballX += ballSpeedX;
            ballY += ballSpeedY;

            // Bounce off top/bottom walls
            if (ballY < BALL_SIZE / 2 || ballY > GAME_HEIGHT - BALL_SIZE / 2) {
                ballSpeedY = -ballSpeedY;
            }
        }

        function resetBall(servingPlayer) {
            ballX = GAME_WIDTH / 2;
            ballY = GAME_HEIGHT / 2;
            ballSpeedX = servingPlayer === 'player' ? -5 : 5; // Start ball towards loser/winner
            ballSpeedY = Math.random() > 0.5 ? 5 : -5;
        }
        
        function computerMovement() {
            // Simple AI: Follow the ball slowly, but don't be perfect
            const cpuCenter = cpuY + PADDLE_HEIGHT / 2;
            if (cpuCenter < ballY - 20) {
                cpuY += PADDLE_SPEED * 0.7;
            } else if (cpuCenter > ballY + 20) {
                cpuY -= PADDLE_SPEED * 0.7;
            }
            // Keep CPU paddle on screen
            if (cpuY < 0) cpuY = 0;
            if (cpuY > GAME_HEIGHT - PADDLE_HEIGHT) cpuY = GAME_HEIGHT - PADDLE_HEIGHT;
        }


        function checkCollision() {
            // Ball position relative to player (right side)
            const playerX = GAME_WIDTH - PADDLE_WIDTH - 20;

            if (ballX > playerX - BALL_SIZE / 2 && ballX < playerX + PADDLE_WIDTH + BALL_SIZE / 2 && 
                ballY > playerY && ballY < playerY + PADDLE_HEIGHT) 
            {
                // Hit player paddle (right side)
                ballSpeedX = -ballSpeedX;
            } 
            
            // Ball position relative to CPU (left side)
            const cpuX = 20;
            if (ballX < cpuX + PADDLE_WIDTH + BALL_SIZE / 2 && ballX > cpuX - BALL_SIZE / 2 &&
                ballY > cpuY && ballY < cpuY + PADDLE_HEIGHT)
            {
                // Hit CPU paddle (left side)
                ballSpeedX = -ballSpeedX;
            }

            // Scoring (Ball goes past the paddle)
            if (ballX < BALL_SIZE / 2) {
                // CPU missed, Player scores
                playerScore++;
                checkWinCondition();
                resetBall('cpu'); // CPU serves
            } else if (ballX > GAME_WIDTH - BALL_SIZE / 2) {
                // Player missed, CPU scores
                cpuScore++;
                checkWinCondition();
                resetBall('player'); // Player serves
            }
        }

        function checkWinCondition() {
            if (playerScore >= WINNING_SCORE) {
                gameOver = true;
                displayMessage('You Won!', 'Congratulations! Click to restart.', startGame);
            } else if (cpuScore >= WINNING_SCORE) {
                gameOver = true;
                displayMessage('You Lost!', 'Better luck next time. Click to restart.', startGame);
            }
        }

        function gameLoop() {
            if (!gameRunning || gameOver) return;

            // 1. Logic
            moveBall();
            computerMovement();
            checkCollision();

            // 2. Drawing
            drawEverything();
            drawScores();

            // 3. Loop
            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            playerScore = 0;
            cpuScore = 0;
            gameOver = false;
            gameRunning = true;
            resetBall('player');
            drawScores();
            gameLoop();
        }
        
        function displayMessage(title, text, action) {
            gameRunning = false;
            const existingMessage = document.getElementById('game-message');
            if (existingMessage) existingMessage.remove();

            const messageBox = document.createElement('div');
            messageBox.id = 'game-message';
            messageBox.className = 'message-box';
            
            messageBox.innerHTML = `
                <h2 class="text-4xl font-extrabold mb-4 text-yellow-400">${title}</h2>
                <p class="text-lg mb-6">${text}</p>
                <button class="start-button">
                    RESTART GAME
                </button>
            `;
            container.appendChild(messageBox);
            
            messageBox.querySelector('.start-button').addEventListener('click', () => {
                messageBox.remove();
                action();
            });
        }


        // --- Responsiveness and Input Handling ---

        function handleResize() {
            // Set internal drawing size
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;

            // Set external style size based on container to maintain aspect ratio
            const containerWidth = container.clientWidth - 32; // - padding
            
            // Calculate scale based on width, but respect height limits
            scaleFactor = containerWidth / GAME_WIDTH;
            let targetHeight = GAME_HEIGHT * scaleFactor;

            // Limit height if the screen is too short
            const maxContainerHeight = window.innerHeight * 0.9 - 100; // Account for header/footer
            if (targetHeight > maxContainerHeight) {
                scaleFactor = maxContainerHeight / GAME_HEIGHT;
                canvas.style.height = `${maxContainerHeight}px`;
                canvas.style.width = `${GAME_WIDTH * scaleFactor}px`;
            } else {
                 canvas.style.width = `${containerWidth}px`;
                 canvas.style.height = `${targetHeight}px`;
            }
        }

        // Mouse/Touch Input Handler
        function handlePaddleMove(e) {
            if (!gameRunning || gameOver) return;
            e.preventDefault(); 
            
            // Determine client Y from mouse or touch
            let clientY = 0;
            if (e.touches && e.touches.length > 0) {
                clientY = e.touches[0].clientY;
            } else if (e.clientY !== undefined) {
                clientY = e.clientY;
            } else {
                return;
            }

            // Calculate the position of the canvas on the screen
            const canvasRect = canvas.getBoundingClientRect();
            
            // Calculate the position of the touch/mouse event relative to the internal canvas dimensions
            const touchY = (clientY - canvasRect.top) / scaleFactor;
            
            // Calculate the new paddle position (center the paddle on the touch/mouse Y)
            const newPlayerY = touchY - (PADDLE_HEIGHT / 2);
            
            // Clamp the paddle position to stay within the game boundaries
            playerY = Math.max(0, Math.min(GAME_HEIGHT - PADDLE_HEIGHT, newPlayerY));
        }

        // Attach listeners
        window.addEventListener('resize', handleResize);
        window.addEventListener('load', () => {
            handleResize();
            displayMessage('Welcome to Pong!', 'Drag the right paddle (green) up and down to hit the ball.', startGame);
        });

        canvas.addEventListener('mousemove', handlePaddleMove);
        canvas.addEventListener('touchmove', handlePaddleMove);
        canvas.addEventListener('touchstart', (e) => {
            handlePaddleMove(e);
            e.preventDefault(); // Prevent scrolling on touch
        });

    </script>
</body>
</html>
