<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classic Pong Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Lesson Learned II.3: Disable panning/zooming for clean touch interactions */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117;
            display: flex;
            flex-direction: column;
            justify-content: center; /* Vertically center the container */
            align-items: center;     /* Horizontally center the container */
            min-height: 100vh;
            overflow: hidden;
            touch-action: none; 
        }
        #game-container {
            /* Aggressive Vertical Fix: Reduced max-height for console stability */
            @apply flex flex-col justify-start items-center p-4 rounded-xl shadow-2xl;
            background-color: #1a202c;
            border: 8px solid #3b82f6;
            max-width: 95vw;
            width: 95%; /* Use fluid width */
            max-height: 65vh; /* Further reduction for console stability */
            height: 100%; 
            box-sizing: border-box;
            position: relative; 
        }
        #pongCanvas {
            background-color: #000;
            display: block;
            flex-grow: 0; 
            margin: 0 auto; /* CRITICAL: Ensure the canvas is horizontally centered as a flex item */
            border-radius: 4px;
        }
        .message-box {
            /* Ensures message box fills the container exactly */
            @apply absolute inset-0 bg-gray-900 bg-opacity-95 flex flex-col justify-center items-center text-white p-4 rounded-md;
            z-index: 100;
            height: 100%; 
            width: 100%;
            box-sizing: border-box;
            border-radius: 4px;
        }
        #game-title {
            /* Fix Title Wrapping: Reduced font size */
            @apply text-2xl font-extrabold text-white mb-4;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <!-- Title with reduced font size -->
        <h1 id="game-title">PONG CLASSIC</h1>
        
        <!-- The Canvas -->
        <canvas id="pongCanvas"></canvas>
        
        <!-- Score Display -->
        <div id="score-display" class="mt-4 text-xl font-mono text-white">PLAYER: 0 | CPU: 0</div>
        
        <!-- Initial Message Box (will disappear on first paddle move) -->
        <div id="initial-message-box" class="message-box">
            <h2 class="text-3xl font-extrabold mb-3 text-yellow-400 text-center">Welcome to Pong!</h2>
            <p class="text-base mb-4 text-center px-2">Move the green paddle (right) to start playing.</p>
            <p class="text-sm text-gray-400">(First to 5 points wins)</p>
        </div>
    </div>

    <script>
        // --- Canvas Setup and Game Variables ---
        const canvas = document.getElementById('pongCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score-display');
        const container = document.getElementById('game-container');
        const initialMessageBox = document.getElementById('initial-message-box');
        
        // Game Dimensions (Internal Drawing Resolution - 4:3 Aspect Ratio)
        const GAME_WIDTH = 400;
        const GAME_HEIGHT = 600;
        let scaleFactor = 1;

        // Paddles
        const PADDLE_WIDTH = 10;
        const PADDLE_HEIGHT = 70;
        const BALL_MARGIN_FROM_PADDLE = PADDLE_WIDTH + 5; // Distance from the paddle edge
        let playerY = (GAME_HEIGHT / 2) - (PADDLE_HEIGHT / 2);
        let cpuY = (GAME_HEIGHT / 2) - (PADDLE_HEIGHT / 2);
        const PADDLE_SPEED = 6;

        // Ball
        const BALL_SIZE = 10;
        let ballX = GAME_WIDTH / 2;
        let ballY = GAME_HEIGHT / 2;
        let ballSpeedX = 5;
        let ballSpeedY = 5;

        // Game State
        let playerScore = 0;
        let cpuScore = 0;
        const WINNING_SCORE = 5;
        let gameRunning = false;
        let gameOver = false;
        let isGameStarted = false; 
        let flashColor = '#000'; 
        let isScoring = false; 

        // --- Core Game Logic (Drawing, Movement, Collision) ---

        function drawRect(x, y, w, h, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x, y, w, h);
        }

        function drawCircle(x, y, r, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2, false);
            ctx.closePath();
            ctx.fill();
        }

        function drawNet() {
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.setLineDash([10, 10]);
            ctx.moveTo(GAME_WIDTH / 2, 0);
            ctx.lineTo(GAME_WIDTH / 2, GAME_HEIGHT);
            ctx.stroke();
        }

        function drawScores() {
            scoreDisplay.textContent = `PLAYER: ${playerScore} | CPU: ${cpuScore}`;
        }

        function drawEverything() {
            // Background - use flashColor here for the effect
            drawRect(0, 0, GAME_WIDTH, GAME_HEIGHT, flashColor);
            drawNet();
            drawRect(GAME_WIDTH - PADDLE_WIDTH - 20, playerY, PADDLE_WIDTH, PADDLE_HEIGHT, '#10b981'); 
            drawRect(20, cpuY, PADDLE_WIDTH, PADDLE_HEIGHT, '#3b82f6'); 
            drawCircle(ballX, ballY, BALL_SIZE / 2, '#ef4444');
        }

        function moveBall() {
            ballX += ballSpeedX;
            ballY += ballSpeedY;

            if (ballY < BALL_SIZE / 2 || ballY > GAME_HEIGHT - BALL_SIZE / 2) {
                ballSpeedY = -ballSpeedY;
            }
        }

        function resetBall(servingPlayer) {
            ballY = GAME_HEIGHT / 2; 

            if (servingPlayer === 'player') {
                // Player scored, Player serves: Ball starts near Player's paddle, heads left (to CPU)
                ballX = GAME_WIDTH - 20 - PADDLE_WIDTH - BALL_SIZE;
                ballSpeedX = -Math.abs(ballSpeedX);
            } else {
                // CPU scored, CPU serves: Ball starts near CPU's paddle, heads right (to Player)
                ballX = 20 + PADDLE_WIDTH + BALL_SIZE;
                ballSpeedX = Math.abs(ballSpeedX);
            }
            
            ballSpeedY = (Math.random() * 4 + 3) * (Math.random() > 0.5 ? 1 : -1); 
        }
        
        function computerMovement() {
            const cpuCenter = cpuY + PADDLE_HEIGHT / 2;
            if (cpuCenter < ballY - 20) {
                cpuY += PADDLE_SPEED * 0.7;
            } else if (cpuCenter > ballY + 20) {
                cpuY -= PADDLE_SPEED * 0.7;
            }
            if (cpuY < 0) cpuY = 0;
            if (cpuY > GAME_HEIGHT - PADDLE_HEIGHT) cpuY = GAME_HEIGHT - PADDLE_HEIGHT;
        }

        function handleScore(servingPlayer) {
            if (isScoring) return; 
            
            gameRunning = false; 
            isScoring = true; 
            flashColor = '#ffff00'; 
            drawEverything(); 
            drawScores(); 

            // Check win condition *after* the score update
            let gameFinished = playerScore >= WINNING_SCORE || cpuScore >= WINNING_SCORE;
            
            // Wait 1000ms (1 second) for visual feedback
            setTimeout(() => {
                flashColor = '#000'; 
                isScoring = false; 
                
                if (gameFinished) {
                    gameOver = true; // Set final game state here
                    if (playerScore >= WINNING_SCORE) {
                        displayMessage('You Won!', 'Congratulations! Move the paddle to restart.');
                    } else { // CPU won
                        displayMessage('You Lost!', 'Better luck next time. Move the paddle to restart.');
                    }
                } else {
                    // Resume game sequence
                    resetBall(servingPlayer);
                    gameRunning = true;
                    gameLoop();
                }
            }, 1000); 
        }

        function checkCollision() {
            if (isScoring) return; 

            const playerX = GAME_WIDTH - PADDLE_WIDTH - 20;
            
            // Player Paddle Collision (right side)
            if (ballX > playerX - BALL_SIZE / 2 && ballX < playerX + PADDLE_WIDTH + BALL_SIZE / 2 && 
                ballY > playerY && ballY < playerY + PADDLE_HEIGHT) 
            {
                ballSpeedX = -Math.abs(ballSpeedX); // Ensure it moves left
            } 
            
            const cpuX = 20;
            // CPU Paddle Collision (left side)
            if (ballX < cpuX + PADDLE_WIDTH + BALL_SIZE / 2 && ballX > cpuX - BALL_SIZE / 2 &&
                ballY > cpuY && ballY < cpuY + PADDLE_HEIGHT)
            {
                ballSpeedX = Math.abs(ballSpeedX); // Ensure it moves right
            }

            // Scoring
            if (ballX < BALL_SIZE / 2) { // Player scores on CPU's side (left)
                playerScore++;
                handleScore('player'); // Player serves next
            } else if (ballX > GAME_WIDTH - BALL_SIZE / 2) { // CPU scores on Player's side (right)
                cpuScore++;
                handleScore('cpu'); // CPU serves next
            }
        }

        function gameLoop() {
            // Only draw/run physics if the game is active
            if (!gameRunning || gameOver) {
                drawEverything();
                return; 
            }
            moveBall();
            computerMovement();
            checkCollision();
            drawEverything();
            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            isGameStarted = true;
            if (initialMessageBox) initialMessageBox.classList.add('hidden'); 
            
            // This is the ONLY place scores are reset.
            playerScore = 0; 
            cpuScore = 0;
            
            gameOver = false;
            isScoring = false;
            gameRunning = true;
            flashColor = '#000';
            
            // Default first serve is always by the player (moving left)
            resetBall('player');
            drawScores();
            gameLoop();
        }
        
        function displayMessage(title, text) {
            gameRunning = false;
            // Show the game over message box 
            initialMessageBox.classList.remove('hidden');
            initialMessageBox.innerHTML = `
                <h2 class="text-3xl font-extrabold mb-3 text-yellow-400 text-center">${title}</h2>
                <p class="text-base mb-4 text-center px-2">${text}</p>
            `;
        }

        // --- Responsiveness and Input Handling ---

        function handleResize() {
            // Set internal drawing size
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;

            // Calculate scaling to fit perfectly within the container
            const overheadTop = canvas.offsetTop; 
            const overheadBottom = scoreDisplay.getBoundingClientRect().height + 20; 
            const availableHeight = container.clientHeight - overheadTop - overheadBottom;
            const availableWidth = container.clientWidth - 32; 

            const scaleX = availableWidth / GAME_WIDTH;
            const scaleY = availableHeight / GAME_HEIGHT;
            
            scaleFactor = Math.min(scaleX, scaleY);
            
            const finalWidth = GAME_WIDTH * scaleFactor;
            const finalHeight = GAME_HEIGHT * scaleFactor;
            
            canvas.style.width = `${finalWidth}px`;
            canvas.style.height = `${finalHeight}px`;

            drawEverything();
            drawScores();
        }

        // Mouse/Touch Input Handler
        function handlePaddleMove(e) {
            e.preventDefault(); 

            // 1. Initial Start
            if (!isGameStarted) {
                startGame();
                return; 
            }

            // 2. Restart After Game Over
            if (gameOver) { 
                startGame();
                return;
            }

            // 3. Ignore if Paused (due to scoring)
            if (!gameRunning) return; 

            // Input reading logic
            let clientY = 0;
            if (e.touches && e.touches.length > 0) {
                clientY = e.touches[0].clientY;
            } else if (e.clientY !== undefined) {
                clientY = e.clientY;
            } else {
                return;
            }

            const canvasRect = canvas.getBoundingClientRect();
            // Calculate position within the internal canvas drawing coordinates
            const touchY = (clientY - canvasRect.top) / scaleFactor;
            const newPlayerY = touchY - (PADDLE_HEIGHT / 2);
            
            playerY = Math.max(0, Math.min(GAME_HEIGHT - PADDLE_HEIGHT, newPlayerY));
        }

        // Attach listeners
        window.addEventListener('resize', handleResize);
        window.addEventListener('load', () => {
            setTimeout(() => {
                handleResize();
                drawEverything(); 
            }, 100);
        });

        // Use the canvas or the whole container for input
        canvas.addEventListener('mousemove', handlePaddleMove);
        canvas.addEventListener('touchmove', handlePaddleMove);
        canvas.addEventListener('touchstart', (e) => {
            handlePaddleMove(e);
            e.preventDefault();
        });

    </script>
</body>
</html>
