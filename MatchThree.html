<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Match-3: Smooth Quest</title>
    <style>
        :root { --bg: #0f0c29; --accent: #24243e; --btn: #00d4ff; }
        body { background: var(--bg); color: #fff; font-family: sans-serif; margin: 0; display: flex; flex-direction: column; align-items: center; touch-action: none; height: 100vh; overflow: hidden; }
        
        .header { width: 100%; display: flex; flex-direction: column; align-items: center; background: var(--accent); padding: 10px 0; border-bottom: 3px solid #302b63; }
        .goals { display: flex; gap: 8px; margin-bottom: 5px; }
        .goal-item { background: rgba(255,255,255,0.05); padding: 5px 10px; border-radius: 8px; text-align: center; min-width: 50px; border: 1px solid rgba(255,255,255,0.1); }
        .stats-bar { font-size: 12px; color: var(--btn); font-weight: bold; }

        #game-container { position: relative; width: 360px; height: 360px; margin-top: 20px; background: rgba(0,0,0,0.3); border-radius: 12px; overflow: hidden; }
        
        .tile { 
            position: absolute; width: 40px; height: 40px; 
            display: flex; align-items: center; justify-content: center; 
            font-size: 24px; border-radius: 6px; cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
            background: rgba(255,255,255,0.05);
            user-select: none;
        }
        
        /* Matching Highlight */
        .tile.matching { transform: scale(1.2); background: #fff; color: #000; z-index: 10; transition: 0.2s; }
        .tile.selected { box-shadow: 0 0 15px #fff; z-index: 5; background: rgba(255,255,255,0.2); }
        
        .missile::after { content: 'üöÄ'; position: absolute; font-size: 10px; bottom: 0; right: 0; }
        .bomb::after { content: 'üí£'; position: absolute; font-size: 10px; bottom: 0; right: 0; }

        .footer { margin-top: 20px; }
        #modal { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--accent); padding: 30px; border-radius: 20px; border: 2px solid var(--btn); text-align: center; z-index: 100; }
    </style>
</head>
<body>

<div class="header">
    <div class="goals" id="goal-container"></div>
    <div class="stats-bar">Moves: <span id="move-val">0</span> | Ratio: <span id="ratio-val">0.00</span></div>
</div>

<div id="game-container"></div>

<div class="footer">
    <button onclick="manualShuffle()" style="background:#333; color:white; border:1px solid #555; padding:8px 16px; border-radius:20px;">Shuffle üé≤</button>
</div>

<div id="modal">
    <h2 id="res-title">Level Complete!</h2>
    <div id="final-stats" style="font-size: 20px; margin: 10px;"></div>
    <button onclick="nextLevel()" style="background: var(--btn); border:none; padding: 10px 20px; border-radius: 5px; font-weight:bold; cursor:pointer;">Next</button>
</div>

<script>
const icons = ['üå∏', 'üòä', '‚≠ê', 'üíé'];
const size = 8;
const tileSize = 45; // 40px + 5px gap
let grid = []; // Now stores objects with unique IDs for DOM persistence
let moves = 0;
let goals = [0, 0, 0, 0];
let targets = [10, 8, 12, 5];
let isBusy = false;
let selected = null;

function init() {
    grid = [];
    for (let r = 0; r < size; r++) {
        grid[r] = [];
        for (let c = 0; c < size; c++) {
            grid[r][c] = { id: Math.random(), type: Math.floor(Math.random() * icons.length), special: null };
        }
    }
    while(findMatches().length > 0) {
        grid.forEach(row => row.forEach(cell => cell.type = Math.floor(Math.random()*icons.length)));
    }
    renderGoals();
    drawBoard();
}

function drawBoard() {
    const container = document.getElementById('game-container');
    const currentTiles = Array.from(container.children);
    const existingIds = new Set();

    grid.forEach((row, r) => {
        row.forEach((cell, c) => {
            existingIds.add(cell.id);
            let div = document.getElementById(cell.id);
            if (!div) {
                div = document.createElement('div');
                div.id = cell.id;
                div.className = 'tile';
                container.appendChild(div);
            }
            div.style.top = `${r * tileSize + 5}px`;
            div.style.left = `${c * tileSize + 5}px`;
            div.innerText = icons[cell.type];
            div.className = `tile ${cell.special || ''} ${selected && selected.r === r && selected.c === c ? 'selected' : ''}`;
            div.onclick = () => handleTileClick(r, c);
        });
    });

    // Remove tiles that aren't in the grid anymore (cleared tiles)
    currentTiles.forEach(tile => {
        if (!existingIds.has(parseFloat(tile.id))) container.removeChild(tile);
    });

    updateStats();
}

async function handleTileClick(r, c) {
    if (isBusy) return;
    if (!selected) {
        selected = {r, c};
        drawBoard();
    } else {
        const dist = Math.abs(r - selected.r) + Math.abs(c - selected.c);
        if (dist === 1) {
            isBusy = true;
            moves++;
            const r1 = selected.r, c1 = selected.c;
            swap(r1, c1, r, c);
            drawBoard();

            await new Promise(res => setTimeout(res, 300)); // Wait for slide

            if (findMatches().length > 0) {
                await processAllMatches(r, c);
            } else {
                swap(r1, c1, r, c); // Snap back
                drawBoard();
            }
        }
        selected = null;
        isBusy = false;
        drawBoard();
    }
}

function swap(r1, c1, r2, c2) {
    const temp = grid[r1][c1];
    grid[r1][c1] = grid[r2][c2];
    grid[r2][c2] = temp;
}

function findMatches() {
    let matches = [];
    for (let r = 0; r < size; r++) {
        for (let c = 0; c < size - 2; c++) {
            if (grid[r][c].type === grid[r][c+1].type && grid[r][c].type === grid[r][c+2].type)
                matches.push({r,c},{r,c:c+1},{r,c:c+2});
        }
    }
    for (let c = 0; c < size; c++) {
        for (let r = 0; r < size - 2; r++) {
            if (grid[r][c].type === grid[r+1][c].type && grid[r][c].type === grid[r+2][c].type)
                matches.push({r,c},{r:r+1,c},{r:r+2,c});
        }
    }
    return matches;
}

async function processAllMatches(spawnR, spawnC) {
    let matches = findMatches();
    if (matches.length === 0) { checkWin(); return; }

    // 1. Highlight matches
    matches.forEach(m => document.getElementById(grid[m.r][m.c].id).classList.add('matching'));
    await new Promise(res => setTimeout(res, 400));

    // 2. Clear matches & track goals
    let toClear = new Set(matches.map(m => `${m.r},${m.c}`));
    let special = matches.length === 4 ? 'missile' : (matches.length >= 5 ? 'bomb' : null);

    toClear.forEach(pos => {
        const [r, c] = pos.split(',').map(Number);
        goals[grid[r][c].type]++;
        grid[r][c].type = -1; // Temp mark
    });

    // 3. Remove from grid
    for(let r=0; r<size; r++) {
        for(let c=0; c<size; c++) {
            if(grid[r][c].type === -1) grid[r][c] = null;
        }
    }
    drawBoard();
    await new Promise(res => setTimeout(res, 100));

    // 4. Drop and Fill
    dropTiles();
    fillTiles();
    drawBoard();
    
    await new Promise(res => setTimeout(res, 400));
    await processAllMatches(); // Cascade
}

function dropTiles() {
    for (let c = 0; c < size; c++) {
        for (let r = size - 1; r >= 0; r--) {
            if (!grid[r][c]) {
                for (let k = r - 1; k >= 0; k--) {
                    if (grid[k][c]) {
                        grid[r][c] = grid[k][c];
                        grid[k][c] = null;
                        break;
                    }
                }
            }
        }
    }
}

function fillTiles() {
    for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
            if (!grid[r][c]) grid[r][c] = { id: Math.random(), type: Math.floor(Math.random()*icons.length), special: null };
        }
    }
}

function renderGoals() {
    const container = document.getElementById('goal-container');
    container.innerHTML = goals.map((g, i) => `
        <div class="goal-item" id="goal-box-${i}">
            <span class="goal-icon">${icons[i]}</span>
            <span class="count">${g}/${targets[i]}</span>
        </div>
    `).join('');
}

function updateStats() {
    goals.forEach((g, i) => {
        const box = document.getElementById(`goal-box-${i}`);
        if(box) {
            box.querySelector('.count').innerText = `${g}/${targets[i]}`;
            box.style.borderColor = g >= targets[i] ? 'var(--btn)' : 'rgba(255,255,255,0.1)';
        }
    });
    const total = goals.reduce((a,b)=>a+b,0);
    const ratio = moves === 0 ? 0 : (total/moves).toFixed(2);
    document.getElementById('move-val').innerText = moves;
    document.getElementById('ratio-val').innerText = ratio;
}

function checkWin() {
    if (goals.every((g, i) => g >= targets[i])) {
        document.getElementById('modal').style.display = 'block';
        const ratio = (goals.reduce((a,b)=>a+b,0) / moves).toFixed(2);
        document.getElementById('final-stats').innerText = `Efficiency: ${ratio}`;
    }
}

function nextLevel() {
    document.getElementById('modal').style.display = 'none';
    moves = 0; goals = [0,0,0,0];
    targets = targets.map(t => Math.floor(Math.random()*10)+10);
    init();
}

function manualShuffle() {
    grid.forEach(row => row.forEach(cell => cell.type = Math.floor(Math.random()*icons.length)));
    drawBoard();
}

init();
</script>
</body>
</html>
