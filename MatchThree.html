<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Match-3: Final Polish</title>
    <style>
        :root { --bg: #0f0c29; --accent: #24243e; --btn: #00f2fe; }
        body { background: var(--bg); color: #fff; font-family: 'Segoe UI', sans-serif; margin: 0; display: flex; flex-direction: column; align-items: center; touch-action: none; height: 100vh; overflow: hidden; }
        .header { width: 100%; display: flex; flex-direction: column; align-items: center; background: var(--accent); padding: 10px 0; border-bottom: 3px solid #302b63; }
        .goals { display: flex; gap: 8px; margin-bottom: 5px; }
        .goal-item { background: rgba(255,255,255,0.1); padding: 5px 12px; border-radius: 10px; text-align: center; border: 2px solid transparent; transition: 0.3s; }
        .stats-bar { font-size: 14px; color: var(--btn); font-weight: bold; letter-spacing: 1px; }
        #game-container { position: relative; width: 360px; height: 360px; margin-top: 15px; background: rgba(0,0,0,0.4); border-radius: 12px; box-shadow: inset 0 0 20px #000; }
        .tile { 
            position: absolute; width: 40px; height: 40px; 
            display: flex; align-items: center; justify-content: center; 
            font-size: 26px; border-radius: 8px; cursor: pointer;
            transition: top 0.4s cubic-bezier(0.25, 0.1, 0.25, 1), left 0.4s cubic-bezier(0.25, 0.1, 0.25, 1), transform 0.2s, opacity 0.2s;
            background: rgba(255,255,255,0.05); user-select: none;
        }
        .tile.selected { box-shadow: 0 0 15px #fff; z-index: 5; background: rgba(255,255,255,0.2); transform: scale(1.1); }
        .tile.matching { transform: scale(0); opacity: 0; }
        /* Special Labels */
        .missile::after { content: 'ðŸš€'; position: absolute; font-size: 12px; bottom: -2px; right: -2px; }
        .bomb::after { content: 'ðŸ’£'; position: absolute; font-size: 12px; bottom: -2px; right: -2px; }
        .footer { margin-top: 20px; }
        #modal { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--accent); padding: 30px; border-radius: 20px; border: 2px solid var(--btn); text-align: center; z-index: 100; box-shadow: 0 0 50px #000; }
    </style>
</head>
<body>

<div class="header">
    <div class="goals" id="goal-container"></div>
    <div class="stats-bar">MOVES: <span id="move-val">0</span> | EFFICIENCY: <span id="ratio-val">0.00</span></div>
</div>
<div id="game-container"></div>
<div class="footer"><button onclick="manualShuffle()" style="background:#333; color:white; border:1px solid #555; padding:8px 20px; border-radius:20px; cursor:pointer;">Shuffle ðŸŽ²</button></div>

<div id="modal">
    <h2 style="color:var(--btn)">Quest Complete!</h2>
    <div id="final-stats" style="font-size: 22px; margin: 20px 0;"></div>
    <button onclick="nextLevel()" style="background: var(--btn); border:none; padding: 12px 25px; border-radius: 8px; font-weight:bold; cursor:pointer; color:#000;">NEXT LEVEL</button>
</div>

<script>
const icons = ['ðŸŒ¸', 'ðŸ˜Š', 'â­', 'ðŸ’Ž'];
const size = 8;
const tileSize = 45; 
let grid = []; 
let moves = 0, goals = [0,0,0,0], targets = [12, 10, 15, 6];
let isBusy = false, selected = null;

function init() {
    const container = document.getElementById('game-container');
    container.innerHTML = '';
    grid = Array.from({length:size}, () => Array.from({length:size}, () => ({ id: 't'+Math.random().toString(36).substr(2,9), type: Math.floor(Math.random()*4), special: null })));
    while(findMatches().length > 0) {
        grid.forEach(r => r.forEach(c => c.type = Math.floor(Math.random()*4)));
    }
    renderGoals();
    drawBoard();
}

function drawBoard() {
    const container = document.getElementById('game-container');
    const existingIds = new Set();
    grid.forEach((row, r) => row.forEach((cell, c) => {
        if (!cell) return;
        existingIds.add(cell.id);
        let div = document.getElementById(cell.id);
        if (!div) {
            div = document.createElement('div');
            div.id = cell.id;
            container.appendChild(div);
        }
        div.className = `tile ${cell.special || ''} ${selected && selected.r === r && selected.c === c ? 'selected' : ''}`;
        div.style.top = `${r * tileSize + 5}px`;
        div.style.left = `${c * tileSize + 5}px`;
        div.innerText = icons[cell.type];
        div.onclick = () => handleTileClick(r, c);
    }));
    Array.from(container.children).forEach(t => { if(!existingIds.has(t.id)) { t.classList.add('matching'); setTimeout(()=>t.remove(), 400); } });
    updateStats();
}

async function handleTileClick(r, c) {
    if (isBusy) return;
    if (!selected) { selected = {r, c}; drawBoard(); }
    else {
        const dist = Math.abs(r-selected.r) + Math.abs(c-selected.c);
        if (dist === 1) {
            isBusy = true; moves++;
            const r1 = selected.r, c1 = selected.c;
            swap(r1, c1, r, c);
            drawBoard();
            await new Promise(res => setTimeout(res, 400));
            if (findMatches().length > 0) { await processMatches(r, c); }
            else { swap(r1, c1, r, c); moves--; drawBoard(); await new Promise(res => setTimeout(res, 400)); }
        }
        selected = null; isBusy = false; drawBoard();
    }
}

function swap(r1, c1, r2, c2) { [grid[r1][c1], grid[r2][c2]] = [grid[r2][c2], grid[r1][c1]]; }

function findMatches() {
    let matches = [];
    for(let r=0; r<size; r++) for(let c=0; c<size-2; c++)
        if(grid[r][c] && grid[r][c+1] && grid[r][c+2] && grid[r][c].type === grid[r][c+1].type && grid[r][c].type === grid[r][c+2].type)
            matches.push({r,c}, {r,c:c+1}, {r,c:c+2});
    for(let c=0; c<size; c++) for(let r=0; r<size-2; r++)
        if(grid[r][c] && grid[r+1][c] && grid[r+2][c] && grid[r][c].type === grid[r+1][c].type && grid[r][c].type === grid[r+2][c].type)
            matches.push({r,c}, {r:r+1,c}, {r:r+2,c});
    return matches;
}

async function processMatches(spawnR, spawnC) {
    let matches = findMatches();
    if (matches.length === 0) { isBusy = false; checkWin(); return; }

    let toClear = new Set(matches.map(m => `${m.r},${m.c}`));
    let specialToSpawn = matches.length === 4 ? 'missile' : (matches.length >= 5 ? 'bomb' : null);

    toClear.forEach(pos => {
        const [r, c] = pos.split(',').map(Number);
        const cell = grid[r][c];
        if (cell.special === 'missile') { for(let i=0; i<size; i++) { toClear.add(`${r},${i}`); toClear.add(`${i},${c}`); } }
        if (cell.special === 'bomb') { for(let i=-1; i<=1; i++) for(let j=-1; j<=1; j++) if(grid[r+i] && grid[r+i][c+j]) toClear.add(`${r+i},${c+j}`); }
    });

    toClear.forEach(pos => {
        const [r, c] = pos.split(',').map(Number);
        if (grid[r][c]) { goals[grid[r][c].type]++; grid[r][c] = null; }
    });

    if (specialToSpawn && spawnR !== undefined) {
        grid[spawnR][spawnC] = { id: 's'+Math.random(), type: Math.floor(Math.random()*4), special: specialToSpawn };
    }

    drawBoard();
    await new Promise(res => setTimeout(res, 400));
    dropAndFill();
    drawBoard();
    await new Promise(res => setTimeout(res, 400));
    await processMatches();
}

function dropAndFill() {
    for(let c=0; c<size; c++) {
        for(let r=size-1; r>=0; r--) {
            if(!grid[r][c]) {
                for(let k=r-1; k>=0; k--) if(grid[k][c]) { grid[r][c]=grid[k][c]; grid[k][c]=null; break; }
            }
        }
        for(let r=0; r<size; r++) if(!grid[r][c]) grid[r][c] = { id: 't'+Math.random(), type: Math.floor(Math.random()*4), special: Math.random() > 0.97 ? 'bomb' : null };
    }
}

function renderGoals() {
    document.getElementById('goal-container').innerHTML = targets.map((t, i) => `
        <div class="goal-item" id="gb${i}"><span style="font-size:20px">${icons[i]}</span> <span id="gc${i}">0/${t}</span></div>
    `).join('');
}

function updateStats() {
    goals.forEach((g, i) => {
        const el = document.getElementById(`gc${i}`);
        if(el) el.innerText = `${g}/${targets[i]}`;
        const box = document.getElementById(`gb${i}`);
        if(box) box.style.borderColor = g >= targets[i] ? 'var(--btn)' : 'transparent';
    });
    const total = goals.reduce((a,b)=>a+b,0);
    document.getElementById('move-val').innerText = moves;
    document.getElementById('ratio-val').innerText = moves === 0 ? "0.00" : (total/moves).toFixed(2);
}

function checkWin() { if (goals.every((g, i) => g >= targets[i])) { 
    const ratio = (goals.reduce((a,b)=>a+b,0) / moves).toFixed(2);
    document.getElementById('final-stats').innerText = `Efficiency: ${ratio}`;
    document.getElementById('modal').style.display = 'block'; 
} }

function nextLevel() {
    document.getElementById('modal').style.display = 'none';
    moves = 0; goals = [0,0,0,0];
    targets = targets.map(t => Math.floor(Math.random()*10)+10);
    init();
}

function manualShuffle() { if(!isBusy) { grid.forEach(row => row.forEach(cell => cell.type = Math.floor(Math.random()*4))); drawBoard(); } }

init();
</script>
</body>
</html>
