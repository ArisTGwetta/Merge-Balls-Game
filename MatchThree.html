<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Match-3: Fixed Smooth</title>
    <style>
        :root { --bg: #0f0c29; --accent: #24243e; --btn: #00d4ff; }
        body { background: var(--bg); color: #fff; font-family: sans-serif; margin: 0; display: flex; flex-direction: column; align-items: center; touch-action: none; height: 100vh; overflow: hidden; }
        .header { width: 100%; display: flex; flex-direction: column; align-items: center; background: var(--accent); padding: 10px 0; border-bottom: 3px solid #302b63; z-index: 10; }
        .goals { display: flex; gap: 8px; margin-bottom: 5px; }
        .goal-item { background: rgba(255,255,255,0.05); padding: 5px 10px; border-radius: 8px; text-align: center; min-width: 50px; border: 1px solid rgba(255,255,255,0.1); transition: 0.3s; }
        .stats-bar { font-size: 12px; color: var(--btn); font-weight: bold; }
        #game-container { position: relative; width: 360px; height: 360px; margin-top: 20px; background: rgba(0,0,0,0.3); border-radius: 12px; }
        .tile { 
            position: absolute; width: 40px; height: 40px; 
            display: flex; align-items: center; justify-content: center; 
            font-size: 24px; border-radius: 6px; cursor: pointer;
            transition: top 0.4s cubic-bezier(0.25, 0.1, 0.25, 1), left 0.4s cubic-bezier(0.25, 0.1, 0.25, 1), transform 0.2s, opacity 0.2s;
            background: rgba(255,255,255,0.05); user-select: none;
        }
        .tile.matching { transform: scale(0); opacity: 0; }
        .tile.selected { box-shadow: 0 0 15px #fff; z-index: 5; background: rgba(255,255,255,0.2); transform: scale(1.1); }
        .footer { margin-top: 20px; }
        #modal { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--accent); padding: 30px; border-radius: 20px; border: 2px solid var(--btn); text-align: center; z-index: 100; box-shadow: 0 0 50px #000; }
    </style>
</head>
<body>

<div class="header">
    <div class="goals" id="goal-container"></div>
    <div class="stats-bar">Moves: <span id="move-val">0</span> | Ratio: <span id="ratio-val">0.00</span></div>
</div>
<div id="game-container"></div>
<div class="footer">
    <button onclick="manualShuffle()" style="background:#333; color:white; border:1px solid #555; padding:8px 16px; border-radius:20px; cursor:pointer;">Shuffle üé≤</button>
</div>
<div id="modal">
    <h2>Level Complete!</h2>
    <div id="final-stats" style="font-size: 20px; margin: 15px;"></div>
    <button onclick="nextLevel()" style="background: var(--btn); border:none; padding: 10px 20px; border-radius: 5px; font-weight:bold; cursor:pointer;">Next</button>
</div>

<script>
const icons = ['üå∏', 'üòä', '‚≠ê', 'üíé'];
const size = 8;
const tileSize = 45; 
let grid = []; 
let moves = 0;
let goals = [0, 0, 0, 0];
let targets = [10, 8, 12, 5];
let isBusy = false;
let selected = null;

function init() {
    grid = [];
    const container = document.getElementById('game-container');
    container.innerHTML = '';
    for (let r = 0; r < size; r++) {
        grid[r] = [];
        for (let c = 0; c < size; c++) {
            grid[r][c] = { id: 't' + Math.random().toString(36).substr(2, 9), type: Math.floor(Math.random() * icons.length) };
        }
    }
    while(findMatches().length > 0) {
        grid.forEach(row => row.forEach(cell => cell.type = Math.floor(Math.random()*icons.length)));
    }
    renderGoals();
    drawBoard();
}

function drawBoard() {
    const container = document.getElementById('game-container');
    const existingTileIds = new Set();

    grid.forEach((row, r) => {
        row.forEach((cell, c) => {
            if (!cell) return;
            existingTileIds.add(cell.id);
            let div = document.getElementById(cell.id);
            if (!div) {
                div = document.createElement('div');
                div.id = cell.id;
                div.className = 'tile';
                container.appendChild(div);
            }
            div.style.top = `${r * tileSize + 5}px`;
            div.style.left = `${c * tileSize + 5}px`;
            div.innerText = icons[cell.type];
            div.className = 'tile' + (selected && selected.r === r && selected.c === c ? ' selected' : '');
            div.onclick = () => handleTileClick(r, c);
        });
    });

    // Clean up DOM elements for tiles no longer in the grid
    Array.from(container.children).forEach(tile => {
        if (!existingTileIds.has(tile.id)) {
            tile.style.opacity = '0';
            tile.style.transform = 'scale(0)';
            setTimeout(() => tile.remove(), 300);
        }
    });
    updateStats();
}

async function handleTileClick(r, c) {
    if (isBusy) return;
    if (!selected) {
        selected = {r, c};
        drawBoard();
    } else {
        const dist = Math.abs(r - selected.r) + Math.abs(c - selected.c);
        if (dist === 1) {
            isBusy = true;
            moves++;
            const r1 = selected.r, c1 = selected.c;
            swap(r1, c1, r, c);
            drawBoard();
            await new Promise(res => setTimeout(res, 400)); 

            if (findMatches().length > 0) {
                await processAllMatches();
            } else {
                swap(r1, c1, r, c); 
                drawBoard();
                await new Promise(res => setTimeout(res, 400));
            }
        }
        selected = null;
        isBusy = false;
        drawBoard();
    }
}

function swap(r1, c1, r2, c2) {
    const temp = grid[r1][c1];
    grid[r1][c1] = grid[r2][c2];
    grid[r2][c2] = temp;
}

function findMatches() {
    let matches = [];
    for (let r = 0; r < size; r++) {
        for (let c = 0; c < size - 2; c++) {
            if (grid[r][c] && grid[r][c+1] && grid[r][c+2] &&
                grid[r][c].type === grid[r][c+1].type && grid[r][c].type === grid[r][c+2].type)
                matches.push({r,c},{r,c:c+1},{r,c:c+2});
        }
    }
    for (let c = 0; c < size; c++) {
        for (let r = 0; r < size - 2; r++) {
            if (grid[r][c] && grid[r+1][c] && grid[r+2][c] &&
                grid[r][c].type === grid[r+1][c].type && grid[r][c].type === grid[r+2][c].type)
                matches.push({r,c},{r:r+1,c},{r:r+2,c});
        }
    }
    return matches;
}

async function processAllMatches() {
    let matches = findMatches();
    if (matches.length === 0) { isBusy = false; checkWin(); return; }

    // 1. Highlight
    matches.forEach(m => {
        const el = document.getElementById(grid[m.r][m.c].id);
        if (el) el.classList.add('matching');
    });
    await new Promise(res => setTimeout(res, 300));

    // 2. Remove & Score
    matches.forEach(m => {
        if (grid[m.r][m.c]) {
            goals[grid[m.r][m.c].type]++;
            grid[m.r][m.c] = null;
        }
    });
    drawBoard();
    await new Promise(res => setTimeout(res, 200));

    // 3. Drop
    for (let c = 0; c < size; c++) {
        for (let r = size - 1; r >= 0; r--) {
            if (!grid[r][c]) {
                for (let k = r - 1; k >= 0; k--) {
                    if (grid[k][c]) {
                        grid[r][c] = grid[k][c];
                        grid[k][c] = null;
                        break;
                    }
                }
            }
        }
    }
    drawBoard();
    await new Promise(res => setTimeout(res, 300));

    // 4. Refill
    for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
            if (!grid[r][c]) grid[r][c] = { id: 't' + Math.random().toString(36).substr(2, 9), type: Math.floor(Math.random()*icons.length) };
        }
    }
    drawBoard();
    await new Promise(res => setTimeout(res, 400));
    
    // Recursive check for cascades
    await processAllMatches();
}

function renderGoals() {
    const container = document.getElementById('goal-container');
    container.innerHTML = targets.map((t, i) => `
        <div class="goal-item" id="goal-box-${i}">
            <span class="goal-icon">${icons[i]}</span>
            <span class="count" id="count-${i}">0/${t}</span>
        </div>
    `).join('');
}

function updateStats() {
    goals.forEach((g, i) => {
        const countEl = document.getElementById(`count-${i}`);
        if(countEl) countEl.innerText = `${g}/${targets[i]}`;
        const box = document.getElementById(`goal-box-${i}`);
        if(box) box.style.borderColor = g >= targets[i] ? 'var(--btn)' : 'rgba(255,255,255,0.1)';
    });
    const total = goals.reduce((a,b)=>a+b,0);
    const ratio = moves === 0 ? 0 : (total/moves).toFixed(2);
    document.getElementById('move-val').innerText = moves;
    document.getElementById('ratio-val').innerText = ratio;
}

function checkWin() {
    if (goals.every((g, i) => g >= targets[i])) {
        const ratio = (goals.reduce((a,b)=>a+b,0) / moves).toFixed(2);
        document.getElementById('final-stats').innerText = `Efficiency: ${ratio}`;
        document.getElementById('modal').style.display = 'block';
    }
}

function nextLevel() {
    document.getElementById('modal').style.display = 'none';
    moves = 0; goals = [0,0,0,0];
    targets = targets.map(t => Math.floor(Math.random()*10)+10);
    init();
}

function manualShuffle() {
    if (isBusy) return;
    grid.forEach(row => row.forEach(cell => cell.type = Math.floor(Math.random()*icons.length)));
    drawBoard();
}

init();
</script>
</body>
</html>
