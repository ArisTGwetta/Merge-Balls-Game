<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Man Maze Runner</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
/* CSS for Responsiveness and Styling */
body {
    font-family: 'Inter', sans-serif;
    /* Use Tailwind classes for styling */
    @apply bg-gray-900 text-white min-h-screen flex items-center justify-center p-4;
    margin: 0;
    padding: 1rem;
    box-sizing: border-box;
    user-select: none;
    /* CRITICAL: Allows full-screen swipe without triggering mobile zoom/scroll */
    touch-action: none; 
}

#app-container {
    @apply flex flex-col items-center justify-center p-4 rounded-xl shadow-2xl;
    width: 100%;
    max-width: 600px;
    background-color: #2d3748;
    border-radius: 16px;
    box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5);
    padding: 1rem;
}

#game-container {
    position: relative;
    width: 90vw; 
    max-width: 500px;
    aspect-ratio: 1 / 1; 
    margin-bottom: 1rem;
    border: 4px solid #f6e05e; 
    border-radius: 8px;
    overflow: hidden;
    flex-grow: 0; 
}

canvas {
    display: block;
    width: 100%; 
    height: 100%;
    background-color: #000; 
    border: 4px solid #3b82f6; 
    box-shadow: 0 0 20px #3b82f6; 
    border-radius: 1rem; 
    transition: border-color 0.5s ease-in-out, box-shadow 0.5s ease-in-out;
}

.pause-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: rgba(0, 0, 0, 0.5);
    color: white;
    font-size: 1.5rem; 
    font-weight: bold;
    line-height: 1.4;
    display: none;
}

#message {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 10;
    text-align: center;
    padding: 1.5rem 2.5rem;
    background-color: rgba(0, 0, 0, 0.9);
    border: 3px solid #63b3ed;
    border-radius: 12px;
    color: #fff;
    font-size: 1.25rem; 
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.6);
    display: none; 
}

.huge-emoji {
    font-size: 2.5rem; 
    line-height: 1;
    display: block;
    margin-bottom: 0.5rem;
}

.text-pacman-yellow {
    color: #f6e05e;
    border-radius: 1rem;
    text-shadow: 0 0 10px #ffcc00;
}

.control-button {
    @apply p-3 m-1 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-full shadow-lg transition duration-150 transform hover:scale-105;
    width: 60px;
    height: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5rem;
}

.restart-button {
    @apply mt-4 p-3 bg-green-500 rounded-lg shadow-md hover:bg-green-600 transition duration-150;
    font-size: 1.25rem;
    /* Ensure the button z-index is above other elements */
    z-index: 20; 
}
</style>
</head>
<body>

    <div id="app-container">
        <h1 class="text-3xl font-extrabold mb-4 text-pacman-yellow">PAC-MAZE RUNNER</h1>
        
        <div id="game-container">
            <canvas id="gameCanvas"></canvas>
            
            <div id="message" class="transition-opacity duration-300"></div>
            <div id="pause-message" class="pause-overlay hidden"></div>
        </div>

        <div id="controls" class="mt-6 w-full flex flex-col items-center">
            <div class="flex justify-center">
                <button class="control-button" data-dir="UP">‚¨ÜÔ∏è</button>
            </div>
            <div class="flex justify-center">
                <button class="control-button" data-dir="LEFT">‚¨ÖÔ∏è</button>
                <div class="w-[60px] h-[60px] m-1"></div> <button class="control-button" data-dir="RIGHT">‚û°Ô∏è</button>
            </div>
            <div class="flex justify-center">
                <button class="control-button" data-dir="DOWN">‚¨áÔ∏è</button>
            </div>
        </div>
    </div>

<script>
    // --- CANVAS AND CONTEXT SETUP ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const messageEl = document.getElementById('message');
    const pauseMessage = document.getElementById('pause-message');
    // Using document.body for full-screen swipe coverage
    const swipeTarget = document.body; 

    // --- GAME CONFIGURATION ---
    let TILE_SIZE; 
    const MAP_WIDTH = 11;
    const MAP_HEIGHT = 13;
    const SPEED = 1.5; 
    const GHOST_SPEED = 1.5;
    // Colors
    const WALL_COLOR_SCATTER = '#3b82f6'; 
    const WALL_COLOR_CHASE = '#8b5cf6';
    const WALL_LINE_SCATTER = '#0e46a7';
    const WALL_LINE_CHASE = '#6d28d9';
    const VICTORY_COLOR = '#10b981';

    // Map Legend: 1=Wall, 0=Dot/Path, 2=Empty
    const INITIAL_MAP = [
        [1,1,1,1,1,1,1,1,1,1,1],
        [1,0,0,0,1,0,1,0,0,0,1],
        [1,0,1,0,1,0,1,0,1,0,1],
        [1,0,0,0,0,0,0,0,0,0,1],
        [1,1,1,0,1,1,1,0,1,1,1], 
        [1,0,0,0,0,0,0,0,0,0,1], 
        [1,0,1,0,1,1,1,0,1,0,1],
        [1,0,0,0,1,0,1,0,0,0,1],
        [1,1,0,1,1,0,1,1,0,1,1],
        [1,0,0,0,0,0,0,0,0,0,1],
        [1,0,1,0,1,0,1,0,1,0,1],
        [1,0,0,0,1,0,1,0,0,0,1], 
        [1,1,1,1,1,1,1,1,1,1,1],
    ];
    let MAP = JSON.parse(JSON.stringify(INITIAL_MAP)); 

    // --- GAME STATE AND ENTITIES ---
    let score = 0; 
    let lives = 3; 
    let gameLoopInterval = null; 
    let gameMode = 'SCATTER'; 
    let gameState = 'PAUSED_START';
    let modeTimer = 0;
    let frameCounter = 0;
    let isFirstGame = true; 

    const SCATTER_DURATION = 7 * 60;
    const CHASE_DURATION = 20 * 60; 
    
    const GHOST_START_GRID = { x: 5, y: 3 }; 
    const GHOST_COLORS = ['red', 'pink', 'cyan', 'orange'];
    let GHOST_BEHAVIORS = [];
    const VICTORY_EMOJIS = ['üòé', 'ü•≥', 'ü§©', 'üòâ'];

    let pacman = {
        col: 5, row: 11,
        x: 0, y: 0, 
        targetX: 0, targetY: 0,
        nextCol: 5, nextRow: 11,
        radius: 0,
        direction: 'UP', 
        requestedDirection: 'UP',
        angle: { start: 0.25, end: 1.75 },
        moving: true,
        isCelebrating: false,
        victoryEmoji: null 
    };
    let GHOSTS = [];
    
    // --- UTILITIES ---
    const getCenterPixel = (col, row) => ({
        x: col * TILE_SIZE + TILE_SIZE / 2,
        y: row * TILE_SIZE + TILE_SIZE / 2, 
    });
    const getRandomEmoji = () => VICTORY_EMOJIS[Math.floor(Math.random() * VICTORY_EMOJIS.length)];

    const setNextTarget = (entity, dir) => {
        let newCol = entity.col;
        let newRow = entity.row;

        switch (dir) {
            case 'UP': newRow -= 1; break;
            case 'DOWN': newRow += 1; break;
            case 'LEFT': newCol -= 1; break;
            case 'RIGHT': newCol += 1; break;
        }

        if (!isWallAtGrid(newCol, newRow)) {
            const { x, y } = getCenterPixel(newCol, newRow);
            entity.targetX = x;
            entity.targetY = y;
            entity.nextCol = newCol; 
            entity.nextRow = newRow;

            entity.direction = dir;
            entity.moving = true;
            return true;
        }
        
        entity.moving = false;
        return false;
    };
    
    const isWallAtGrid = (col, row) => {
        if (row >= 0 && row < MAP_HEIGHT && col >= 0 && col < MAP_WIDTH) {
            return MAP[row][col] === 1;
        }
        return true; 
    };


    // --- GHOST AI (Unchanged) ---
    function setupNewGameBehaviors() {
        const behaviorPool = [
            { id: 'hunter', targetFn: targetPacman, scatterTarget: { x: MAP_WIDTH - 2, y: 1 } },
            { id: 'ambusher', targetFn: targetAmbush, scatterTarget: { x: 1, y: 1 } }
        ];
        const shuffledBehaviors = behaviorPool.sort(() => Math.random() - 0.5);
        GHOST_BEHAVIORS = [
            { name: 'Ghost A', behavior: shuffledBehaviors[0].id, targetFn: shuffledBehaviors[0].targetFn, scatterTarget: shuffledBehaviors[0].scatterTarget },
            { name: 'Ghost B', behavior: shuffledBehaviors[1].id, targetFn: shuffledBehaviors[1].targetFn, scatterTarget: shuffledBehaviors[1].scatterTarget }
        ];
    }
    function initializeGhosts() {
        const colorPool = [...GHOST_COLORS].sort(() => Math.random() - 0.5);
        GHOSTS = GHOST_BEHAVIORS.map((behavior, index) => {
             const g = {
                name: behavior.name, color: colorPool[index], 
                scatterTarget: behavior.scatterTarget, targetFn: behavior.targetFn,
                col: GHOST_START_GRID.x, row: GHOST_START_GRID.y,
                direction: 'LEFT', moving: true,
                nextCol: GHOST_START_GRID.x, nextRow: GHOST_START_GRID.y 
            };
            const { x: gx, y: gy } = getCenterPixel(g.col, g.row);
            g.x = gx; g.y = gy;
            setNextTarget(g, g.direction);
            return g;
        });
    }
    function targetPacman() { return { x: pacman.col, y: pacman.row }; }
    function targetAmbush() {
        const pGrid = { x: pacman.col, y: pacman.row };
        let targetX = pGrid.x; let targetY = pGrid.y;
        const offset = 4;
        if (pacman.moving) {
            switch (pacman.direction) {
                case 'UP': targetY -= offset; break;
                case 'DOWN': targetY += offset; break;
                case 'LEFT': targetX -= offset; break;
                case 'RIGHT': targetX += offset; break;
            }
        }
        targetX = Math.max(1, Math.min(MAP_WIDTH - 2, targetX));
        targetY = Math.max(1, Math.min(MAP_HEIGHT - 2, targetY));
        return { x: targetX, y: targetY };
    }
    const getTargetTile = (ghost) => {
        if (gameMode === 'SCATTER') { return ghost.scatterTarget; }
        return ghost.targetFn();
    };

    const getGhostDirection = (ghost) => {
        const target = getTargetTile(ghost);
        const possibleMoves = [
            { dir: 'UP', dx: 0, dy: -1 }, { dir: 'DOWN', dx: 0, dy: 1 },
            { dir: 'LEFT', dx: -1, dy: 0 }, { dir: 'RIGHT', dx: 1, dy: 0 }
        ];
        let bestMove = null; 
        let minDistanceSq = Infinity;
        let validMoves = [];

        for (const move of possibleMoves) {
            const nextGridX = ghost.col + move.dx;
            const nextGridY = ghost.row + move.dy;
            if (isWallAtGrid(nextGridX, nextGridY)) { continue; }
            
            const isUTurn = (
                (ghost.direction === 'UP' && move.dir === 'DOWN') ||
                (ghost.direction === 'DOWN' && move.dir === 'UP') ||
                (ghost.direction === 'LEFT' && move.dir === 'RIGHT') ||
                (ghost.direction === 'RIGHT' && move.dir === 'LEFT')
            );

            if (!isUTurn) {
                validMoves.push({ move, distSq: Math.pow(target.x - nextGridX, 2) + Math.pow(target.y - nextGridY, 2) });
            }
        }
        
        for (const moveData of validMoves) {
            if (moveData.distSq < minDistanceSq) {
                minDistanceSq = moveData.distSq;
                bestMove = moveData.move.dir;
            }
        }

        if (bestMove === null) {
            const reverseMap = { 'UP': 'DOWN', 'DOWN': 'UP', 'LEFT': 'RIGHT', 'RIGHT': 'LEFT' };
            bestMove = reverseMap[ghost.direction] || ghost.direction;
        }

        return bestMove; 
    };

    // --- CORE RESPONSIBLE RESIZING FUNCTION (Unchanged) ---
    function resizeCanvas() {
        const container = document.getElementById('game-container');
        const containerWidth = container.clientWidth;
        
        TILE_SIZE = Math.floor(containerWidth / MAP_WIDTH);
        
        if (TILE_SIZE < 1) { 
            TILE_SIZE = 1;
        }

        canvas.width = MAP_WIDTH * TILE_SIZE;
        canvas.height = MAP_HEIGHT * TILE_SIZE;
        
        pacman.radius = TILE_SIZE / 2 - 2;

        const resetEntityPosition = (entity) => {
             const { x, y } = getCenterPixel(entity.col, entity.row);
             entity.x = x;
             entity.y = y;
             entity.targetX = x;
             entity.targetY = y;
             entity.nextCol = entity.col;
             entity.nextRow = entity.row;
             entity.radius = TILE_SIZE / 2 - 2;
        };
        
        resetEntityPosition(pacman);
        GHOSTS.forEach(resetEntityPosition);

        pauseMessage.style.width = canvas.width + 'px';
        pauseMessage.style.height = canvas.height + 'px';
        
        if (gameState === 'WIN') {
            pacman.targetX = canvas.width / 2;
            pacman.targetY = canvas.height / 2;
        }
    }
    
    // --- MOVEMENT LOGIC (ROBUST FLOATING-POINT FIX) ---
    function moveEntity(entity, speed) {
        if (!entity.moving) return false;
        const dx = entity.targetX - entity.x;
        const dy = entity.targetY - entity.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist > 0) {
            const step = Math.min(speed, dist);
            
            // Check for arrival by comparing step distance to remaining distance.
            if (step >= dist - 0.001) { 
                // Snap to target and update grid position using stored coordinates
                entity.x = entity.targetX; 
                entity.y = entity.targetY;
                entity.col = entity.nextCol; 
                entity.row = entity.nextRow;
                return true; // Arrived
            } else {
                // Not arrived, move the step distance
                entity.x += (dx / dist) * step;
                entity.y += (dy / dist) * step;
                return false;
            }
        }
        return true; 
    }
    
    function moveEntityToCenter(entity, speed = 2) {
        const dx = entity.targetX - entity.x;
        const dy = entity.targetY - entity.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > 5) {
            const step = Math.min(speed, dist);
            entity.x += (dx / dist) * step;
            entity.y += (dy / dist) * step;
            return false;
        } else {
            entity.x = entity.targetX;
            entity.y = entity.targetY; 
            return true; // Arrived at center
        }
    }

    function updatePacmanPosition() {
        if (!pacman.moving && pacman.requestedDirection !== pacman.direction) {
             setNextTarget(pacman, pacman.requestedDirection);
        }
        
        const arrived = moveEntity(pacman, SPEED);
        if (arrived) {
            eatDots();
            if (pacman.requestedDirection !== pacman.direction) {
                if (setNextTarget(pacman, pacman.requestedDirection)) {
                    // Turn successful
                } else {
                    setNextTarget(pacman, pacman.direction);
                }
            } else {
                setNextTarget(pacman, pacman.direction);
            }
        }
        
        // Mouth animation logic
        if (pacman.moving) {
            pacman.angle.start += 0.05;
            pacman.angle.end -= 0.05;
            if (pacman.angle.start > 0.3 || pacman.angle.end < 1.7) {
                pacman.angle.start = 0.05;
                pacman.angle.end = 1.95;
            }
        } else {
            pacman.angle.start = 0;
            pacman.angle.end = 2;
        }
    }
    
    function moveGhosts() {
        GHOSTS.forEach(ghost => {
            const arrived = moveEntity(ghost, GHOST_SPEED);
            if (arrived || !ghost.moving) {
                const desiredDirection = getGhostDirection(ghost);
                setNextTarget(ghost, desiredDirection);
            }
        });
    }

    // --- GAMEPLAY LOGIC ---
    function switchGameMode() {
        modeTimer++;
        let duration = gameMode === 'CHASE' ? CHASE_DURATION : SCATTER_DURATION;
        if (modeTimer >= duration) {
            gameMode = gameMode === 'CHASE' ? 'SCATTER' : 'CHASE';
            modeTimer = 0;
            const reverseMap = { 'UP': 'DOWN', 'DOWN': 'UP', 'LEFT': 'RIGHT', 'RIGHT': 'LEFT' };
            GHOSTS.forEach(ghost => {
                if (ghost.moving) {
                    ghost.direction = reverseMap[ghost.direction];
                    setNextTarget(ghost, ghost.direction); 
                } 
            });
            updateWallColor();
        }
    }
    
    function checkGhostCollision() {
        const distanceThreshold = pacman.radius * 2 * 0.8;
        GHOSTS.forEach(ghost => {
            const dx = pacman.x - ghost.x;
            const dy = pacman.y - ghost.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < distanceThreshold) {
                handlePacmanDeath();
            }
        });
    }
    
    function respawnEntities() {
        lives--;
        
        if (lives > 0) {
            initializeGhosts();
            pacman.col = 5; pacman.row = 11;
            pacman.direction = 'UP'; pacman.requestedDirection = 'UP';
            pacman.moving = true; 
            const { x, y } = getCenterPixel(pacman.col, pacman.row);
            pacman.x = x; pacman.y = y;
            pacman.targetX = x; pacman.targetY = y;
            pacman.nextCol = pacman.col; 
            pacman.nextRow = pacman.row; 
            setNextTarget(pacman, pacman.direction);
            
            gameState = 'RUNNING'; 
            pauseMessage.classList.add('hidden');
        } else {
            endGame(false);
        }
    }

    function handlePacmanDeath() {
        pacman.moving = false;
        GHOSTS.forEach(g => g.moving = false); 
        
        if (lives > 1) { 
            gameState = 'PAUSED_DEATH';
            pauseMessage.classList.remove('hidden');
            pauseMessage.textContent = "CAUGHT!";
            
            setTimeout(() => {
                pauseMessage.textContent = "READY!";
                setTimeout(() => {
                    pauseMessage.textContent = "ESCAPE!"; 
                    setTimeout(() => {
                        respawnEntities(); 
                    }, 1000); 
                }, 1000); 
            }, 1500); 
        } else {
            respawnEntities(); 
        }
    }
    
    function resetGame() {
        setupNewGameBehaviors();
        MAP = JSON.parse(JSON.stringify(INITIAL_MAP));
        score = 0;
        lives = 3;
        
        pacman.col = 5; pacman.row = 11;
        pacman.direction = 'UP';
        pacman.requestedDirection = 'UP';
        pacman.moving = true;
        pacman.isCelebrating = false;
        const { x, y } = getCenterPixel(pacman.col, pacman.row);
        pacman.x = x; pacman.y = y;
        pacman.nextCol = pacman.col; 
        pacman.nextRow = pacman.row; 
        setNextTarget(pacman, pacman.direction); 

        initializeGhosts();
        gameMode = 'SCATTER';
        modeTimer = 0;
        
        updateWallColor(); 
        hideGameMessage();
    }
    
    function startGameLoop() {
        if (gameLoopInterval) {
            clearInterval(gameLoopInterval);
        }
        gameLoopInterval = setInterval(gameLoop, 1000 / 60);
    }

    // Exported function for the Restart button's onclick handler
    window.resetGameAndStart = function() {
        resetGame();
        gameState = 'RUNNING'; 
        startGameLoop();
    }

    function eatDots() {
        const { row, col } = pacman;
        if (MAP[row][col] === 0) {
            MAP[row][col] = 2;
            score += 10;
            checkWinCondition();
        }
    }

    function checkWinCondition() {
        let remainingDots = 0;
        for (let r = 0; r < MAP_HEIGHT; r++) {
            for (let c = 0; c < MAP_WIDTH; c++) {
                if (MAP[r][c] === 0) { remainingDots++; }
            }
        }
        if (remainingDots === 0) { endGame(true); }
    }

    function endGame(won) {
        GHOSTS.forEach(g => g.moving = false);
        
        gameState = won ? 'WIN' : 'LOSE';
        updateWallColor();
        
        const titleText = won ? "I'M FREE!" : "ONE OF US! ONE OF US!";
        const titleColor = won ? 'text-green-500' : 'text-red-500';

        if (!won) {
            // Stop the loop immediately on loss
            clearInterval(gameLoopInterval); 
            gameLoopInterval = null; 
        } else {
            // Setup win animation
            pacman.moving = false;
            pacman.isCelebrating = true;
            pacman.victoryEmoji = getRandomEmoji();
            pacman.targetX = canvas.width / 2;
            pacman.targetY = canvas.height / 2;
            
            // Ensure the loop is running to handle the win animation.
            if (!gameLoopInterval) {
                startGameLoop(); 
            }
        }
        
        showEndGameScreen(titleText, score, titleColor);
    }
    
    // --- DRAWING FUNCTIONS (Unchanged) ---
    function updateWallColor() {
        if (gameState === 'WIN') {
            canvas.style.borderColor = VICTORY_COLOR;
            canvas.style.boxShadow = `0 0 20px ${VICTORY_COLOR}`;
            return { wallColor: 'transparent', lineColor: 'transparent' };
        }

        const wallColor = gameMode === 'CHASE' ? WALL_COLOR_CHASE : WALL_COLOR_SCATTER;
        const lineColor = gameMode === 'CHASE' ? WALL_LINE_CHASE : WALL_LINE_SCATTER;
        canvas.style.borderColor = wallColor;
        canvas.style.boxShadow = `0 0 20px ${wallColor}`;
        
        return { wallColor, lineColor };
    }
    function drawMap() {
        const { wallColor, lineColor } = updateWallColor();
        for (let r = 0; r < MAP_HEIGHT; r++) {
            for (let c = 0; c < MAP_WIDTH; c++) {
                const x = c * TILE_SIZE;
                const y = r * TILE_SIZE;

                if (MAP[r][c] === 1) { 
                    if (gameState !== 'WIN') { 
                        ctx.fillStyle = wallColor;
                        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                        ctx.strokeStyle = lineColor;
                        ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);
                    } else {
                        ctx.fillStyle = '#000';
                        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                    }
                } else if (MAP[r][c] === 0) { 
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(x + TILE_SIZE / 2, y + TILE_SIZE / 2, TILE_SIZE / 10, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
    }

    function drawPacman() {
        const radius = pacman.radius;
        let drawX = pacman.x;
        let drawY = pacman.y;
        
        if (gameState === 'WIN') {
            const isCentered = Math.abs(drawX - pacman.targetX) < 1;
            const wiggleOffset = isCentered ? Math.sin(frameCounter * 0.4) * 5 : 0; 
            drawX += wiggleOffset;
            ctx.fillStyle = 'yellow';
            ctx.beginPath();
            ctx.arc(drawX, drawY, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.font = `${radius}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(pacman.victoryEmoji, drawX, drawY + 2);
            return;
        }

        if (gameState === 'LOSE' || gameState === 'PAUSED_DEATH') {
            ctx.fillStyle = 'yellow';
            ctx.beginPath();
            ctx.arc(drawX, drawY, radius, Math.PI, 0, false);
            ctx.rect(drawX - radius, drawY, radius * 2, radius * 1.5);
            ctx.fill();

            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(drawX - radius * 0.3, drawY - radius * 0.1, radius * 0.2, 0, Math.PI * 2);
            ctx.arc(drawX + radius * 0.3, drawY - radius * 0.1, radius * 0.2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'blue'; 
            ctx.beginPath();
            ctx.arc(drawX - radius * 0.3, drawY - radius * 0.1, radius * 0.1, 0, Math.PI * 2);
            ctx.arc(drawX + radius * 0.3, drawY - radius * 0.1, radius * 0.1, 0, Math.PI * 2);
            ctx.fill();

            return;
        }

        ctx.fillStyle = 'yellow';
        ctx.beginPath();
        let baseAngle = 0;
        switch (pacman.direction) {
            case 'UP': baseAngle = -0.5; break; 
            case 'DOWN': baseAngle = 0.5; break; 
            case 'LEFT': baseAngle = 1; break; 
            case 'RIGHT': baseAngle = 0; break;
        }
        ctx.arc(
            pacman.x, pacman.y, pacman.radius,
            (pacman.angle.start + baseAngle) * Math.PI,
            (pacman.angle.end + baseAngle) * Math.PI
        );
        ctx.lineTo(pacman.x, pacman.y);
        ctx.fill();
    }

    function drawGhosts() {
        if (gameState === 'WIN') { return; }
        const radius = pacman.radius;
        const isCelebrating = gameState === 'LOSE';
        const shake = isCelebrating ? Math.sin(frameCounter * 0.2) * 2 : 0;

        GHOSTS.forEach(ghost => {
            const centerX = ghost.x + shake;
            const centerY = ghost.y;
            ctx.fillStyle = ghost.color;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, Math.PI, 0, false);
            ctx.rect(centerX - radius, centerY, radius * 2, radius * 1.5);
            
            const footSize = radius / 3;
            ctx.lineTo(centerX + radius, centerY + radius * 1.5);
            ctx.lineTo(centerX + radius - footSize, centerY + radius * 1.5 - footSize);
            ctx.lineTo(centerX + radius - footSize * 2, centerY + radius * 1.5);
            ctx.lineTo(centerX + radius - footSize * 3, centerY + radius * 1.5 - footSize);
            ctx.lineTo(centerX + radius - footSize * 4, centerY + radius * 1.5);
            ctx.lineTo(centerX - radius, centerY + radius * 1.5);

            ctx.fill();
            
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(centerX - radius * 0.3, centerY - radius * 0.1, radius * 0.2, 0, Math.PI * 2);
            ctx.arc(centerX + radius * 0.3, centerY - radius * 0.1, radius * 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'blue'; 
            ctx.beginPath();
            ctx.arc(centerX - radius * 0.3, centerY - radius * 0.1, radius * 0.1, 0, Math.PI * 2);
            ctx.arc(centerX + radius * 0.3, centerY - radius * 0.1, radius * 0.1, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    function showGameMessage(text, emoji = null) {
        let content = '';
        if (emoji) { content += `<span class="huge-emoji">${emoji}</span>`; }
        content += `<span>${text}</span>`;
        messageEl.innerHTML = content;
        messageEl.style.display = 'block';
    }

    function showEndGameScreen(title, finalScore, titleColor) {
        messageEl.innerHTML = `
            <h1 class="text-3xl font-extrabold ${titleColor}">${title}</h1>
            <p class="text-xl mt-1 mb-4 text-white">Score: ${finalScore}</p>
            <button onclick="window.resetGameAndStart()" class="restart-button">Play Again</button>`;
        messageEl.style.display = 'block';
    }

    function hideGameMessage() {
        messageEl.style.display = 'none';
    }
    // --- END DRAWING FUNCTIONS ---

    // --- INPUT HANDLERS ---
    function setRequestedDirection(direction) {
        if (gameState === 'PAUSED_START' && isFirstGame) {
             isFirstGame = false;
        }

        if (gameState === 'PAUSED_START' || gameState === 'RUNNING') {
            hideGameMessage();
            gameState = 'RUNNING';
            pacman.requestedDirection = direction;
        }
    }
    
    // Keyboard and Button Controls
    document.addEventListener('keydown', (e) => {
        switch (e.key) {
            case 'ArrowUp': case 'w': setRequestedDirection('UP'); break;
            case 'ArrowDown': case 's': setRequestedDirection('DOWN'); break;
            case 'ArrowLeft': case 'a': setRequestedDirection('LEFT'); break;
            case 'ArrowRight': case 'd': setRequestedDirection('RIGHT'); break;
        }
        e.preventDefault(); 
    });
    document.querySelectorAll('.control-button').forEach(button => {
        const direction = button.getAttribute('data-dir');
        button.addEventListener('click', () => setRequestedDirection(direction));
        button.addEventListener('touchstart', (e) => {
            setRequestedDirection(direction);
            e.preventDefault(); 
        });
    });

    // --- SWIPE INPUT HANDLERS (Full-screen coverage) ---
    let touchStartX = 0;
    let touchStartY = 0;
    const swipeThreshold = 50; 

    swipeTarget.addEventListener('touchstart', (e) => {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
    }, { passive: false });

    swipeTarget.addEventListener('touchend', (e) => {
        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;

        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;

        if (Math.abs(deltaX) > swipeThreshold || Math.abs(deltaY) > swipeThreshold) {
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                if (deltaX > 0) { setRequestedDirection('RIGHT'); } 
                else { setRequestedDirection('LEFT'); }
            } else {
                if (deltaY > 0) { setRequestedDirection('DOWN'); } 
                else { setRequestedDirection('UP'); }
            }
        } else {
             // Handle tap/small drag to start game
             if (gameState === 'PAUSED_START' && lives > 0) {
                 setRequestedDirection('UP');
             }
        }
        e.preventDefault(); 
    }, { passive: false });


    // --- MAIN GAME LOOP ---
    function gameLoop() {
        frameCounter++;
        ctx.clearRect(0, 0, canvas.width, canvas.height); 

        drawMap();

        if (gameState === 'RUNNING') {
            switchGameMode();
            updatePacmanPosition();
            moveGhosts();
            checkGhostCollision();
        } else if (gameState === 'WIN') {
            // Run win animation
            if (moveEntityToCenter(pacman)) { 
                // Stop the loop once Pacman is centered and dancing
                if (gameLoopInterval) {
                    clearInterval(gameLoopInterval);
                    gameLoopInterval = null;
                }
            }
        } 
        
        drawGhosts();
        drawPacman();
    }
    
    // --- INITIALIZATION ---
    function initialize() {
        resizeCanvas(); 
        resetGame(); 
        
        if (isFirstGame) {
            gameState = 'PAUSED_START';
            showGameMessage("Press an arrow key, button, or swipe to start!", 'üïπÔ∏è'); 
        }

        window.addEventListener('resize', resizeCanvas); 
        
        startGameLoop(); 
        
        // **CRITICAL FIX: Explicitly call gameLoop once to render the first frame immediately.**
        gameLoop(); 
    }

    window.onload = initialize;

</script>
</body>
</html>
