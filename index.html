<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Merge Balls: Ascension v4</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align to start to better handle smaller screens */
            min-height: 100vh;
            margin: 0;
            background-color: #2c3e50;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            overflow: hidden; /* Prevent body scroll */
            touch-action: none;
            padding-top: 10px; /* Increased buffer */
            padding-bottom: 10px; /* Increased buffer */
            box-sizing: border-box; /* Include padding in height calculations */
        }

        #game-container {
            position: relative;
            background-color: #ecf0f1;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            padding: 10px; /* Reduced padding slightly to save vertical space */
            box-sizing: border-box; /* Include padding in width/height */
            
            /* === VERTICAL RESPONSIVENESS FIXES START HERE === */
            /* New strategy: Maximize usage of available width AND height */
            /* Use clamp to manage game container size */
            width: clamp(280px, 95vw, 400px); /* Min 280px, max 400px, responsive to 95% viewport width */
            
            /* Reduced to 95vh to provide a larger safety margin against browser UI bars */
            height: 95vh; 
            max-height: 700px; /* Max height for very tall screens */
            /* Min-height to ensure it doesn't disappear on tiny screens */
            min-height: 500px; 
            
            /* Flex-grow to fill available space between items if body is 'justify-content: space-between' */
            flex-grow: 1; 
            /* === VERTICAL RESPONSIVENESS FIXES END HERE === */

            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Header Layout */
        #header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 8px; /* Slightly reduced margin */
            padding: 0 10px;
            box-sizing: border-box;
            /* Give the header a fixed height so canvas can calculate remaining space */
            min-height: 60px; /* Ensure header has space even with fluid fonts */
        }

        .score-box {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            line-height: 1.1; /* Tighter line height for scores */
        }

        .score-box:last-of-type {
            align-items: flex-end;
        }

        .label {
            font-size: clamp(10px, 2.5vw, 12px); /* Responsive font size */
            color: #7f8c8d;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .value {
            font-size: clamp(20px, 6vw, 28px); /* Responsive font size */
            color: #2c3e50;
            font-weight: 800;
        }
        
        #best-score-box .value {
            color: #3498db;
        }

        #next-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #next-ball-preview {
            /* Responsive next ball size */
            width: clamp(28px, 7vw, 35px);
            height: clamp(28px, 7vw, 35px);
            border: 2px solid rgba(0,0,0,0.1);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(12px, 3vw, 14px); /* Responsive font size */
            color: #fff;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            font-weight: bold;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            transition: all 0.2s ease;
        }
        #next-container .label {
            font-size: clamp(8px, 2vw, 10px);
        }

        #game-canvas {
            border: 4px solid #34495e;
            background-color: #fff;
            display: block;
            border-bottom-left-radius: 8px;
            border-bottom-right-radius: 8px;
            cursor: crosshair;
            
            /* === VERTICAL RESPONSIVENESS FIXES START HERE === */
            width: 100%; /* Take 100% of the game-container's width */
            /* This height will be adjusted by JavaScript to maintain aspect ratio */
            flex-grow: 1; /* Allow it to grow, but JS will enforce aspect ratio */
            /* Add min-height to prevent it from collapsing if JS is slow */
            min-height: 300px; 
            /* === VERTICAL RESPONSIVENESS FIXES END HERE === */
        }

        /* Flash animation for "Ascension" */
        @keyframes flash {
            0% { background-color: #ecf0f1; }
            25% { background-color: #2ecc71; } /* Success Green */
            50% { background-color: #ecf0f1; }
            75% { background-color: #2ecc71; }
            100% { background-color: #ecf0f1; }
        }
        .flash-effect {
            animation: flash 0.6s ease-out;
        }

    </style>
</head>
<body>
    <div id="game-container">
        
        <div id="header">
            <div class="score-box">
                <span class="label">Score</span>
                <span id="current-score" class="value">0</span>
            </div>
            <div id="next-container">
                <div id="next-ball-preview"></div>
                <span class="label" style="font-size: 10px; margin-top:2px;">Next Drop</span>
            </div>
            <div class="score-box" id="best-score-box">
                <span class="label">Best</span>
                <span id="best-score" class="value">0</span>
            </div>
        </div>

        <canvas id="game-canvas"></canvas>
    </div>

    <script>
        // --- CONFIGURATION ---
        // These constants define the *internal* coordinate system for physics and drawing (0 to 400 on X, 0 to 600 on Y).
        const INTERNAL_GAME_WIDTH = 400;
        const INTERNAL_GAME_HEIGHT = 600; // Original aspect ratio 400:600 = 2:3
        const MIN_BALL_SIZE = 20;
        const GRAVITY = 0.55; 
        const FRICTION = 0.96; 
        const WALL_BOUNCE = 0.4;
        const PHYSICS_SUBSTEPS = 8; 
        const ASCENSION_TARGET_VALUE = 11; // The value that triggers board clear (Dark Green Ball)

        // 11 Colors (1-11)
        const BALL_COLORS = [
            '#FF4D4D', '#FF9F43', '#FDCB6E', '#00D2D3', '#54A0FF', 
            '#5F27CD', '#FF9FF3', '#D980FA', '#B53471', '#C4E538', '#2ecc71' // <-- Target color
        ];

        // --- SETUP ---
        const container = document.getElementById('game-container');
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('current-score');
        const bestScoreElement = document.getElementById('best-score');
        const nextBallElement = document.getElementById('next-ball-preview');
        const headerElement = document.getElementById('header');


        // High DPI Scaling
        const dpr = window.devicePixelRatio || 1;
        // Canvas internal dimensions are now set by JS on resize to match aspect ratio
        // and its *physical* size is set by CSS.
        // The drawing context scales to fit the internal dimensions.
        // ctx.scale(dpr, dpr); <-- This happens in handleResize initially and on subsequent resizes

        // --- STATE ---
        let balls = [];
        let score = 0;
        let highScore = localStorage.getItem('mergeBallsBest') || 0;
        let isDropping = false;
        let dropX = INTERNAL_GAME_WIDTH / 2; // Use internal width for drop position
        let currentDroppableBall = null;
        let isTouching = false; // Track touch state

        // Initialize UI
        bestScoreElement.textContent = highScore;

        // --- CLASS ---
        class Ball {
            constructor(x, y, radius, value, color) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.value = value;
                this.color = color;
                this.vx = 0;
                this.vy = 0;
                this.mass = radius * 1.5;
                this.isDroppable = false;
                this.isDead = false;
            }

            draw() {
                if (this.isDead) return;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = 'rgba(255,255,255,0.4)';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = `bold ${Math.max(12, Math.floor(this.radius * 0.8))}px Arial`;
                ctx.shadowColor = "rgba(0,0,0,0.3)";
                ctx.shadowBlur = 3;
                ctx.fillText(this.value, this.x, this.y);
                ctx.shadowBlur = 0;
            }

            stepMovement() {
                if (this.isDead) return;
                
                if (this.isDroppable) {
                    this.x += (dropX - this.x) * 0.2;
                } else {
                    this.vy += GRAVITY / PHYSICS_SUBSTEPS;
                    this.x += this.vx / PHYSICS_SUBSTEPS;
                    this.y += this.vy / PHYSICS_SUBSTEPS;
                    this.handleWallCollisions();
                }
            }

            applyFriction() {
                if (!this.isDroppable && !this.isDead) {
                    this.vx *= FRICTION;
                    this.vy *= FRICTION;
                }
            }

            handleWallCollisions() {
                // Use INTERNAL_GAME_WIDTH and INTERNAL_GAME_HEIGHT for physics bounds
                if (this.x - this.radius < 0) {
                    this.x = this.radius;
                    this.vx = -Math.abs(this.vx) * WALL_BOUNCE;
                }
                if (this.x + this.radius > INTERNAL_GAME_WIDTH) {
                    this.x = INTERNAL_GAME_WIDTH - this.radius;
                    this.vx = Math.abs(this.vx) * -WALL_BOUNCE;
                }
                if (this.y + this.radius > INTERNAL_GAME_HEIGHT) {
                    this.y = INTERNAL_GAME_HEIGHT - this.radius;
                    this.vy = Math.abs(this.vy) * -WALL_BOUNCE;
                    if (Math.abs(this.vy) < 0.5) this.vy = 0;
                    if (Math.abs(this.vx) < 0.1) this.vx = 0;
                }
            }
        }

        // --- HELPERS ---

        function generateRandomBallConfig() {
            const randomValue = Math.floor(Math.random() * 3) + 1;
            const radius = MIN_BALL_SIZE + (randomValue - 1) * 7;
            const color = BALL_COLORS[(randomValue - 1) % BALL_COLORS.length];
            return { value: randomValue, radius: radius, color: color };
        }

        let nextBallConfig = generateRandomBallConfig();

        function createDroppableBall() {
            currentDroppableBall = new Ball(
                dropX, 50, 
                nextBallConfig.radius,
                nextBallConfig.value,
                nextBallConfig.color
            );
            currentDroppableBall.isDroppable = true;
            balls.push(currentDroppableBall);
            nextBallConfig = generateRandomBallConfig();
            updateNextBallPreview();
        }

        function updateNextBallPreview() {
            nextBallElement.style.backgroundColor = nextBallConfig.color;
            nextBallElement.textContent = nextBallConfig.value;
        }

        function triggerAscension() {
            container.classList.add('flash-effect'); 
            setTimeout(() => container.classList.remove('flash-effect'), 600);
            
            balls.forEach(ball => {
                if (ball.value >= ASCENSION_TARGET_VALUE) {
                    ball.isDead = true;
                }
            });

            score += 10000;
            scoreElement.textContent = score;
            checkHighScore();
        }

        function checkHighScore() {
            if (score > highScore) {
                highScore = score;
                bestScoreElement.textContent = highScore;
                localStorage.setItem('mergeBallsBest', highScore);
            }
        }

        function resolveInteraction(ballA, ballB) {
            if (ballA.isDead || ballB.isDead) return;

            const dx = ballB.x - ballA.x;
            const dy = ballB.y - ballA.y;
            const distSq = dx*dx + dy*dy;
            const minDist = ballA.radius + ballB.radius;
            
            if (distSq < minDist * minDist) {
                if (ballA.value === ballB.value) {
                    ballA.isDead = true;
                    ballB.isDead = true;

                    const newVal = ballA.value + 1;
                    
                    if (newVal >= ASCENSION_TARGET_VALUE) {
                        triggerAscension();
                        return; 
                    }

                    const newRad = MIN_BALL_SIZE + (newVal - 1) * 7;
                    const newColor = BALL_COLORS[(newVal - 1) % BALL_COLORS.length];
                    const midX = (ballA.x + ballB.x) / 2;
                    const midY = (ballA.y + ballB.y) / 2;

                    const newBall = new Ball(
                        midX, midY, 
                        Math.min(newRad, 140), 
                        newVal, newColor
                    );
                    newBall.vy = -2;
                    
                    balls.push(newBall);

                    score += Math.pow(2, newVal) * 10;
                    scoreElement.textContent = score;
                    checkHighScore();
                    
                    return; 
                }

                const dist = Math.sqrt(distSq);
                if (dist === 0) return; 

                const overlap = minDist - dist;
                const nx = dx / dist;
                const ny = dy / dist;
                
                const totalMass = ballA.mass + ballB.mass;
                const ratioA = ballB.mass / totalMass;
                const ratioB = ballA.mass / totalMass;

                ballA.x -= overlap * nx * ratioA;
                ballA.y -= overlap * ny * ratioA;
                ballB.x += overlap * nx * ratioB;
                ballB.y += overlap * ny * ratioB;

                const rVx = ballB.vx - ballA.vx;
                const rVy = ballB.vy - ballA.vy;
                const velAlongNormal = rVx * nx + rVy * ny;

                if (velAlongNormal > 0) return;

                const restitution = 0.2; 
                let j = -(1 + restitution) * velAlongNormal;
                j /= (1 / ballA.mass + 1 / ballB.mass);

                const impulseX = j * nx;
                const impulseY = j * ny;

                ballA.vx -= impulseX / ballA.mass;
                ballA.vy -= impulseY / ballA.mass;
                ballB.vx += impulseX / ballB.mass;
                ballB.vy += impulseY / ballB.mass;
            }
        }

        // --- INPUT HANDLING ---

        function updateDropPosition(clientX) {
            const rect = canvas.getBoundingClientRect();
            // Calculate scale factor based on actual canvas physical width and internal game width
            const scaleFactor = INTERNAL_GAME_WIDTH / rect.width;

            let x = (clientX - rect.left) * scaleFactor;
            
            x = Math.max(nextBallConfig.radius, Math.min(INTERNAL_GAME_WIDTH - nextBallConfig.radius, x));
            dropX = x;
        }

        // Mouse Events
        canvas.addEventListener('mousemove', (e) => {
            if (isDropping) return;
            updateDropPosition(e.clientX);
        });

        canvas.addEventListener('mousedown', (e) => {
            if (isDropping || !currentDroppableBall) return;
            dropBall();
        });

        // Touch Events (Drag & Release Logic)
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); 
            if (isDropping) return;
            isTouching = true;
            updateDropPosition(e.touches[0].clientX);
        }, {passive: false});

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isDropping || !isTouching) return;
            updateDropPosition(e.touches[0].clientX);
        }, {passive: false});

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (isDropping || !isTouching) return;
            isTouching = false;
            if (currentDroppableBall) dropBall();
        });

        function dropBall() {
            isDropping = true;
            currentDroppableBall.isDroppable = false;
            currentDroppableBall.vy = 8;
            currentDroppableBall = null;

            setTimeout(() => {
                createDroppableBall();
                isDropping = false;
            }, 600);
        }

        // --- GAME LOOP ---
        function gameLoop() {
            ctx.clearRect(0, 0, INTERNAL_GAME_WIDTH, INTERNAL_GAME_HEIGHT);

            // Aim Line
            if (currentDroppableBall) {
                currentDroppableBall.x += (dropX - currentDroppableBall.x) * 0.2;
                
                ctx.beginPath();
                ctx.moveTo(currentDroppableBall.x, currentDroppableBall.y);
                ctx.lineTo(currentDroppableBall.x, INTERNAL_GAME_HEIGHT);
                ctx.strokeStyle = 'rgba(52, 73, 94, 0.4)';
                ctx.setLineDash([6, 6]);
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Sub-stepped Physics
            for (let s = 0; s < PHYSICS_SUBSTEPS; s++) {
                balls.forEach(b => b.stepMovement());
                for (let i = 0; i < balls.length; i++) {
                    for (let j = i + 1; j < balls.length; j++) {
                        if (balls[i].isDroppable || balls[j].isDroppable) continue;
                        resolveInteraction(balls[i], balls[j]);
                    }
                }
            }

            balls = balls.filter(b => !b.isDead);

            balls.forEach(b => {
                b.applyFriction();
                b.draw();
            });

            // Game Over Line & Logic (Dead Line is at Y=100)
            const deadLineY = 100;
            const isNearGameOver = balls.some(b => !b.isDroppable && b.y < 200);

            if (isNearGameOver) {
                ctx.beginPath();
                ctx.moveTo(0, deadLineY);
                ctx.lineTo(INTERNAL_GAME_WIDTH, deadLineY);
                ctx.strokeStyle = 'rgba(231, 76, 60, 0.6)';
                ctx.lineWidth = 3;
                ctx.setLineDash([8, 8]);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            if (balls.some(b => !b.isDroppable && b.y + b.radius < deadLineY && Math.abs(b.vy) < 0.2)) {
                // Game Over state
                ctx.fillStyle = 'rgba(44, 62, 80, 0.95)';
                ctx.fillRect(0, 0, INTERNAL_GAME_WIDTH, INTERNAL_GAME_HEIGHT);
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.font = 'bold 40px Segoe UI';
                ctx.fillText('GAME OVER', INTERNAL_GAME_WIDTH/2, INTERNAL_GAME_HEIGHT/2 - 20);
                ctx.font = '20px Segoe UI';
                ctx.fillText(`Final Score: ${score}`, INTERNAL_GAME_WIDTH/2, INTERNAL_GAME_HEIGHT/2 + 30);
                
                const restartHandler = () => location.reload();
                canvas.addEventListener('mousedown', restartHandler, {once:true});
                canvas.addEventListener('touchstart', restartHandler, {once:true});
                return;
            }

            requestAnimationFrame(gameLoop);
        }
        
        // --- RESIZE HANDLER (Crucial for vertical responsiveness) ---
        function handleResize() {
            // Get the computed physical width of the canvas
            const containerRect = container.getBoundingClientRect();
            const headerHeight = headerElement.getBoundingClientRect().height;

            // Calculate available height for the canvas within the container
            // Subtract header height and container's top/bottom padding (2 * 10px from #game-container padding)
            const availableCanvasHeight = containerRect.height - headerHeight - (2 * 10); 
            const desiredCanvasWidth = containerRect.width - (2 * 10); // Subtract container's left/right padding

            // Calculate aspect ratios
            const gameAspectRatio = INTERNAL_GAME_WIDTH / INTERNAL_GAME_HEIGHT; // 400 / 600 = 0.666...
            const currentContainerAspectRatio = desiredCanvasWidth / availableCanvasHeight;

            let finalCanvasWidth = desiredCanvasWidth;
            let finalCanvasHeight = availableCanvasHeight;

            // Adjust to fit within the container while maintaining aspect ratio
            if (currentContainerAspectRatio > gameAspectRatio) {
                // Container is wider than game, constrain by height
                finalCanvasWidth = availableCanvasHeight * gameAspectRatio;
                finalCanvasHeight = availableCanvasHeight;
            } else {
                // Container is taller than game, constrain by width
                finalCanvasHeight = desiredCanvasWidth / gameAspectRatio;
                finalCanvasWidth = desiredCanvasWidth;
            }
            
            // Set the *physical* CSS dimensions of the canvas element
            canvas.style.width = `${finalCanvasWidth}px`;
            canvas.style.height = `${finalCanvasHeight}px`;

            // Set the *internal drawing* dimensions of the canvas context
            // These should always match INTERNAL_GAME_WIDTH and INTERNAL_GAME_HEIGHT
            canvas.width = INTERNAL_GAME_WIDTH * dpr;
            canvas.height = INTERNAL_GAME_HEIGHT * dpr;
            ctx.scale(dpr, dpr); // Apply DPR scaling once
        }

        window.addEventListener('resize', handleResize);


        // --- STARTUP ---
        handleResize(); // Call once at start to set initial canvas size
        updateNextBallPreview();
        createDroppableBall();
        requestAnimationFrame(gameLoop);

    </script>
</body>
</html>
