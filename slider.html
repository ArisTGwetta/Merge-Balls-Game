<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Slider Game - Merge Balls</title>
    <style>
        :root { --bg: #0f172a; --card: #1e293b; --accent: #38bdf8; --text: #f8fafc; }
        body { margin: 0; background: var(--bg); color: var(--text); font-family: system-ui; overflow: hidden; display: flex; flex-direction: column; align-items: center; height: 100vh; }
        #header { width: 320px; padding: 15px; display: flex; justify-content: space-between; align-items: center; z-index: 10; }
        .mode-toggle { display: flex; gap: 5px; background: var(--card); padding: 4px; border-radius: 8px; }
        .mode-btn { border: none; background: none; color: #94a3b8; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 12px; }
        .mode-btn.active { background: var(--accent); color: white; }
        #game-area { width: 320px; height: 446px; background: var(--card); position: relative; border: 4px solid #334155; border-radius: 12px; overflow: hidden; touch-action: none; }
        #grid-container { position: absolute; width: 100%; height: 100%; }
        .block { position: absolute; border-radius: 6px; border: 2px solid rgba(0,0,0,0.2); box-sizing: border-box; transition: top 0.25s cubic-bezier(0.4, 0, 0.2, 1), left 0.1s ease-out; cursor: grab; }
        .block:active { cursor: grabbing; transform: scale(0.98); }
        .block.flash { filter: brightness(3) white; transform: scale(1.1); transition: all 0.1s ease-out; z-index: 10; }
        .ghost-row { position: absolute; bottom: 0; left: 0; height: 6px; width: 100%; display: flex; background: rgba(255, 255, 255, 0.05); z-index: 5; pointer-events: none; }
        .ghost-segment { height: 100%; border-right: 1px solid rgba(255,255,255,0.1); transition: background 0.3s ease; }
        .preview-box { display: flex; flex-direction: column; align-items: center; }
        .preview-label { font-size: 9px; color: #94a3b8; margin-bottom: 2px; text-transform: uppercase; }
        .preview-block { height: 15px; border-radius: 3px; border: 1px solid rgba(0,0,0,0.2); }
    </style>
</head>
<body>
    <div id="header">
        <div style="font-size: 14px;">Score: <span id="score" style="color: var(--accent)">0</span></div>
        <div id="next-container" class="preview-box" style="visibility: hidden;">
            <div class="preview-label">NEXT DROP</div>
            <div id="preview-display" class="preview-block"></div>
        </div>
        <div class="mode-toggle">
            <button id="btn-slider" class="mode-btn active" onclick="setMode('slider')">SLIDER</button>
            <button id="btn-falling" class="mode-btn" onclick="setMode('falling')">FALLING</button>
        </div>
    </div>
    <div id="game-area">
        <div id="grid-container"></div>
        <div id="ghost-row" class="ghost-row"></div>
    </div>
<script>
const gridWidth = 8, gridHeight = 11, cellSize = 40;
let score = 0, blocks = [], gameMode = 'slider', isBusy = false;
let nextBlockData = null;
window.nextRowLayout = null; 
const colors = ['#ff4757', '#2ed573', '#1e90ff', '#ffa502', '#70a1ff', '#eccc68'];

function setMode(m) {
    gameMode = m;
    document.getElementById('btn-slider').classList.toggle('active', m === 'slider');
    document.getElementById('btn-falling').classList.toggle('active', m === 'falling');
    document.getElementById('next-container').style.visibility = (m === 'falling') ? 'visible' : 'hidden';
    resetGame();
}

function predictNextRow() {
    let layout = new Array(gridWidth).fill(null);
    let x = 0;
    while (x < gridWidth - 1) {
        let w = Math.floor(Math.random() * 3) + 1;
        if (x + w >= gridWidth) w = gridWidth - x - 1;
        if (Math.random() > 0.3) {
            for (let i = 0; i < w; i++) layout[x + i] = { isStart: (i === 0), width: w };
        }
        x += w + 1;
    }
    window.nextRowLayout = layout;
}

function generateNext() {
    nextBlockData = { width: Math.floor(Math.random() * 3) + 1, color: colors[Math.floor(Math.random() * colors.length)] };
    const pDisplay = document.getElementById('preview-display');
    pDisplay.style.width = (nextBlockData.width * 15) + 'px';
    pDisplay.style.backgroundColor = nextBlockData.color;
}

function createBlock(x, y, width, color) {
    return { id: 'b' + Math.random().toString(36).substr(2,9), x, y, width, color: color || colors[Math.floor(Math.random()*colors.length)], flash: false };
}

function spawnPredictedRow(y) {
    if (!window.nextRowLayout) predictNextRow();
    for (let x = 0; x < gridWidth; x++) {
        let cell = window.nextRowLayout[x];
        if (cell && cell.isStart) {
            blocks.push(createBlock(x, y, cell.width));
        }
    }
    predictNextRow(); 
}

function draw() {
    const container = document.getElementById('grid-container');
    const ghostContainer = document.getElementById('ghost-row');
    const ids = new Set(blocks.map(b => b.id));
    blocks.forEach(b => {
        let el = document.getElementById(b.id);
        if (!el) {
            el = document.createElement('div');
            el.id = b.id; el.className = 'block';
            el.onmousedown = (e) => startDrag(e, b);
            el.ontouchstart = (e) => startDrag(e, b);
            container.appendChild(el);
        }
        el.style.width = (b.width * cellSize) + 'px';
        el.style.left = (b.x * cellSize) + 'px';
        el.style.top = ((gridHeight - 1 - b.y) * cellSize) + 'px';
        el.style.backgroundColor = b.color;
        if (b.flash) el.classList.add('flash'); else el.classList.remove('flash');
    });
    Array.from(container.children).forEach(child => { if (!ids.has(child.id)) child.remove(); });
    if (ghostContainer && window.nextRowLayout) {
        ghostContainer.innerHTML = '';
        window.nextRowLayout.forEach(cell => {
            const seg = document.createElement('div');
            seg.className = 'ghost-segment';
            seg.style.width = cellSize + 'px';
            seg.style.background = cell ? 'rgba(46, 213, 115, 0.4)' : 'rgba(0,0,0,0.7)';
            ghostContainer.appendChild(seg);
        });
    }
    document.getElementById('score').innerText = score;
}

let activeBlock = null, startX = 0, originalX = 0;
function startDrag(e, block) {
    if (isBusy) return;
    activeBlock = block;
    startX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
    originalX = block.x;
    window.onmousemove = drag; window.ontouchmove = drag;
    window.onmouseup = endDrag; window.ontouchend = endDrag;
}

function drag(e) {
    if (!activeBlock) return;
    const currentX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
    const diff = Math.round((currentX - startX) / cellSize);
    let newX = Math.max(0, Math.min(originalX + diff, gridWidth - activeBlock.width));
    if (!blocks.find(b => b.y === activeBlock.y && b.id !== activeBlock.id && newX < b.x + b.width && newX + activeBlock.width > b.x)) {
        activeBlock.x = newX; draw();
    }
}

async function endDrag() {
    window.onmousemove = null; window.ontouchmove = null;
    if (!activeBlock) return;
    activeBlock = null; isBusy = true;
    await applyGravity();
    if (gameMode === 'slider') {
        blocks.forEach(b => b.y++); draw();
        await new Promise(r => setTimeout(r, 250));
        spawnPredictedRow(0); draw();
        await new Promise(r => setTimeout(r, 200));
    } else {
        const x = Math.floor(Math.random() * (gridWidth - nextBlockData.width));
        blocks.push(createBlock(x, gridHeight - 1, nextBlockData.width, nextBlockData.color));
        generateNext();
    }
    await applyGravity(); isBusy = false; draw();
    if (blocks.some(b => b.y >= gridHeight - 1)) { alert("Game Over!"); resetGame(); }
}

async function applyGravity() {
    let changed = true;
    while (changed) {
        changed = false; blocks.sort((a, b) => a.y - b.y);
        for (let b of blocks) {
            while (b.y > 0) {
                if (!blocks.find(o => o.id !== b.id && o.y === b.y - 1 && b.x < o.x + o.width && b.x + b.width > o.x)) {
                    b.y--; changed = true;
                } else break;
            }
        }
        if (changed) { draw(); await new Promise(r => setTimeout(r, 150)); }
        for (let y = 0; y < gridHeight; y++) {
            let rowFill = new Array(gridWidth).fill(false);
            let rowBlocks = blocks.filter(b => b.y === y);
            rowBlocks.forEach(b => { for (let i = 0; i < b.width; i++) rowFill[b.x + i] = true; });
            if (rowFill.every(f => f)) {
                rowBlocks.forEach(b => b.flash = true); draw();
                await new Promise(r => setTimeout(r, 250));
                blocks = blocks.filter(b => b.y !== y);
                score += 100; changed = true; draw();
            }
        }
    }
}

function resetGame() {
    blocks = []; score = 0; window.nextRowLayout = null; 
    predictNextRow(); // Get layout for first row
    spawnPredictedRow(0); // Uses first layout, then calls predict for next
    spawnPredictedRow(1); 
    spawnPredictedRow(2); 
    generateNext(); draw();
}
resetGame();
</script>
</body>
</html>
