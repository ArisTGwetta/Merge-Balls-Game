<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Pac Maze Rebuild</title>

<style>
    * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
    }

    body {
        background: #0f172a;
        color: white;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        user-select: none;
        touch-action: none;
        overscroll-behavior: none;
    }

    #app-container {
        width: 100%;
        max-width: 520px;
        padding: 12px;
    }

    #game-container {
        position: relative;
        width: 100%;
        aspect-ratio: 1 / 1;
        background: black;
        border-radius: 16px;
        overflow: hidden;
        box-shadow: 0 0 25px rgba(59, 130, 246, 0.6);
    }

    canvas {
        width: 100%;
        height: 100%;
        display: block;
        background: black;
    }

    .overlay {
        position: absolute;
        inset: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 2rem;
        font-weight: bold;
        background: rgba(0, 0, 0, 0.6);
        z-index: 10;
        pointer-events: none;
    }

    .hidden {
        display: none;
    }
</style>
</head>

<body>
    <div id="app-container">
        <div id="game-container">
            <canvas id="gameCanvas"></canvas>

            <!-- Overlays -->
            <div id="message" class="overlay hidden"></div>
            <div id="pause-message" class="overlay hidden"></div>
        </div>
    </div>

<script>



/* =========================================================
   BLOCK 0 â€” GLOBAL VARIABLE DECLARATIONS
   ========================================================= */

let wallColor = '#1e90ff';
let speedMultiplier = 1.0;
let TILE_SIZE = 0;

let gameMode = 'SCATTER';
let modeTimer = 0;
let frameCounter = 0;

let score = 0;
let lives = 3;

let MAP = [];
let GHOSTS = [];
let GHOST_BEHAVIORS = [];

let deathPhase = 'ALIVE';
let deathTimer = 0;

let touchStartX = null;
let touchStartY = null;
let activeTouch = false;

let transitionFlash = 0;
let isNight = false;

let returningPauseStarted = false;
let returningPauseFrames = 0;

let pacGhostJoinProgress = 0;


/* =========================================================
   End of BLOCK 0 
   ========================================================= */



/* =========================================================
   BLOCK 1 â€” SCRIPT START
   Canvas + DOM references only (no game logic yet)
   ========================================================= */

window.gameState = 'LOADING';

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

wallColor = '#1e90ff'; // visible blue walls

const messageEl = document.getElementById('message');
const pauseMessage = document.getElementById('pause-message');

// Full-screen swipe coverage (mobile)
const swipeTarget = document.body;

/* =========================================================
   End of Block 1
   ========================================================= */


/* =========================================================
   BLOCK 2 â€” CONSTANTS, GLOBALS, GAME STATE
   ========================================================= */

/* =========================================================
   SPEED TUNING (PHASE 1 - still block 2)
   ========================================================= */

// Base movement speeds (fraction of tile per frame)
const PACMAN_SPEED = 0.08;     // try 0.10 â€“ 0.14
const GHOST_SPEED  = 0.07;     // slightly slower feels fair

// Optional modifiers (future use)
speedMultiplier = 1.0;     // can change for modes later

/* =========================================================
   TURN BUFFERING -still block 2)
   ========================================================= */

// How close to tile center Pac-Man must be to allow buffered turn
const TURN_TOLERANCE = 0.25; // fraction of tile (0.2â€“0.35 feels good)

/* =========================================================
   MOBILE DRAG INPUT - still block 2)
   ========================================================= */

const SWIPE_ACTIVATION_DISTANCE = 12; // pixels (10â€“16 feels good)

/* =========================================================
   
 PAUSE
   ========================================================= */

const DEATH_PAUSE_MS = 400; // try 300â€“600




// --- GRID CONFIG ---
const MAP_WIDTH = 11;
const MAP_HEIGHT = 13;
TILE_SIZE = 0;

// --- GAME STATE ---
window.gameState  = 'PAUSED_START'; // PAUSED_START, RUNNING, PAUSED_DEATH, WIN, LOSE
gameMode = 'SCATTER';       // SCATTER / CHASE
modeTimer = 0;
frameCounter = 0;

// --- SCORE / LIVES ---
score = 0;
lives = 3;

// --- MAP DATA ---
const INITIAL_MAP = [
    [1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,1,0,1,0,0,0,1],
    [1,0,1,0,1,0,1,0,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,0,1,1,1,0,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,0,1,1,1,0,1,0,1],
    [1,0,0,0,1,0,1,0,0,0,1],
    [1,1,0,1,1,0,1,1,0,1,1],
    [1,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,0,1,0,1,0,1,0,1],
    [1,0,0,0,1,0,1,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1]
];

MAP = JSON.parse(JSON.stringify(INITIAL_MAP));

// --- PACMAN ENTITY ---
const pacman = {
    col: 5,
    row: 11,
    nextCol: 5,
    nextRow: 11,
    x: 0,
    y: 0,
    targetX: 0,
    targetY: 0,
    direction: 'UP',
    requestedDirection: 'UP',
    radius: 0,
    moving: true,
    mouthAngle: 0,
    mouthClosing: false,
    isCelebrating: false,
    isGhost: false

};

// --- GHOST DATA ---
const GHOST_COLORS = ['red', 'pink', 'cyan', 'orange'];
const GHOST_START_GRID = { x: 5, y: 3 };

GHOSTS = [];
GHOST_BEHAVIORS = [];

/* =========================================================
   End of Block 2
   ========================================================= */





/* =========================================================
   BLOCK 3 â€” GRID, MOVEMENT & COLLISION HELPERS
   ========================================================= */

// --- DIRECTIONS ---
const DIRS = {
    UP:    { x:  0, y: -1 },
    DOWN:  { x:  0, y:  1 },
    LEFT:  { x: -1, y:  0 },
    RIGHT: { x:  1, y:  0 }
};

function oppositeDirection(dir) {
    return (
        dir === 'UP'    ? 'DOWN'  :
        dir === 'DOWN'  ? 'UP'    :
        dir === 'LEFT'  ? 'RIGHT' :
        dir === 'RIGHT' ? 'LEFT'  :
        dir
    );
}

// --- GRID SAFETY ---
function isWall(col, row) {
    if (
        col < 0 || col >= MAP_WIDTH ||
        row < 0 || row >= MAP_HEIGHT
    ) return true;

    return MAP[row][col] === 1;
}

// --- GRID â†” PIXEL ---
function getCenterPixel(col, row) {
    return {
        x: col * TILE_SIZE + TILE_SIZE / 2,
        y: row * TILE_SIZE + TILE_SIZE / 2
    };
}

// --- MOVEMENT CHECK ---
function canMove(entity, direction) {
    const d = DIRS[direction];
    return !isWall(entity.col + d.x, entity.row + d.y);
}

// --- TARGET TILE ---
function setNextTarget(entity, direction) {
    const d = DIRS[direction];

    const nextCol = entity.col + d.x;
    const nextRow = entity.row + d.y;

    // HARD WALL GUARD (prevents ghost wall-crossing)
    if (isWall(nextCol, nextRow)) {
        entity.nextCol = entity.col;
        entity.nextRow = entity.row;
        return;
    }

    entity.nextCol = nextCol;
    entity.nextRow = nextRow;

    const { x, y } = getCenterPixel(nextCol, nextRow);
    entity.targetX = x;
    entity.targetY = y;
}

// --- MOVE TOWARD TARGET (GRID-LOCKED) ---
function moveEntity(entity, speed) {
    const dx = entity.targetX - entity.x;
    const dy = entity.targetY - entity.y;

    // Arrival threshold (prevents float drift)
    if (Math.abs(dx) < 0.5 && Math.abs(dy) < 0.5) {
        entity.x = entity.targetX;
        entity.y = entity.targetY;
        entity.col = entity.nextCol;
        entity.row = entity.nextRow;
        return true;
    }

    const dist = Math.hypot(dx, dy);
    const step = Math.min(speed, dist);

    entity.x += (dx / dist) * step;
    entity.y += (dy / dist) * step;

    return false;
}

// --- CANVAS & TILE SIZE (MAP-AUTHORITATIVE) ---

function resizeCanvas() {
    const container = canvas.parentElement;

    const maxWidth  = container.clientWidth  || window.innerWidth;
    const maxHeight = container.clientHeight || window.innerHeight;

    TILE_SIZE = Math.max(
        8,
        Math.floor(
            Math.min(
                maxWidth  / MAP_WIDTH,
                maxHeight / MAP_HEIGHT
            )
        )
    );

    canvas.width  = TILE_SIZE * MAP_WIDTH;
    canvas.height = TILE_SIZE * MAP_HEIGHT;

    pacman.radius = TILE_SIZE * 0.42;
}


window.addEventListener('resize', resizeCanvas);

/* =========================================================
   End of Block 3
   ========================================================= */

/* =========================================================
   BLOCK 4 â€” MAP & PELLET RENDERING (NO ENGINE HOOKS)
   ========================================================= */

function drawMap() {
    if (deathPhase === 'CELEBRATION') return;

    for (row = 0; row < MAP.length; row++) {
        for (col = 0; col < MAP[row].length; col++) {

            const tile = MAP[row][col];
            const x = col * TILE_SIZE;
            const y = row * TILE_SIZE;

            /* ----------------------------------------------------
               1. Distance from Pac-Man (computed once per tile)
               ---------------------------------------------------- */
            let dist = 0;
            if (isNight) {
                const dx = (col + 0.5) - (pacman.x / TILE_SIZE);
                const dy = (row + 0.5) - (pacman.y / TILE_SIZE);
                dist = Math.sqrt(dx*dx + dy*dy);
            }

            /* ----------------------------------------------------
               2. WALLS (fade with distance)
               ---------------------------------------------------- */
            if (tile === 1) {

                if (isNight) {
                    // Fade curve for walls
                    const brightness = Math.max(0.30, 1 - dist * 0.10);

                    // wallColor is already your day/night color
                    // We fade it toward black
                    const r = Math.floor(parseInt(wallColor.slice(1,3),16) * brightness);
                    const g = Math.floor(parseInt(wallColor.slice(3,5),16) * brightness);
                    const b = Math.floor(parseInt(wallColor.slice(5,7),16) * brightness);

                    ctx.fillStyle = `rgb(${r},${g},${b})`;
                } else {
                    ctx.fillStyle = wallColor;
                }

                ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
            }

            /* ----------------------------------------------------
               3. FLOOR (fade with distance)
               ---------------------------------------------------- */
            else {

                let brightness = 1;

                if (isNight) {
                    brightness = Math.max(0.25, 1 - dist * 0.10);
                }

                ctx.fillStyle = `rgba(0,0,0,${brightness})`;
                ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
            }

            /* ----------------------------------------------------
               4. PELLETS (fade with distance)
               ---------------------------------------------------- */
            if (tile === 0) {

                let brightness = 1;

                if (isNight) {
                    brightness = Math.max(0.15, 1 - dist * 0.12);

                    ctx.shadowColor = `rgba(255,255,255,${brightness})`;
                    ctx.shadowBlur = 8 * brightness;
                } else {
                    ctx.shadowBlur = 0;
                }

                ctx.fillStyle = `rgba(255,255,255,${brightness})`;
                ctx.beginPath();
                ctx.arc(
                    x + TILE_SIZE / 2,
                    y + TILE_SIZE / 2,
                    TILE_SIZE * 0.1,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            }
        }
    }
}

/* =========================================================
   End of Block 4
   ========================================================= */




/* =========================================================
   BLOCK 5 â€” PAC-MAN LOGIC (NO RENDER HOOKS)
   ========================================================= */

// --- INPUT ---
document.addEventListener('keydown', (e) => {
    const keyMap = {
        ArrowUp: 'UP', KeyW: 'UP',
        ArrowDown: 'DOWN', KeyS: 'DOWN',
        ArrowLeft: 'LEFT', KeyA: 'LEFT',
        ArrowRight: 'RIGHT', KeyD: 'RIGHT'
    };

    if (keyMap[e.code]) {
        pacman.requestedDirection = keyMap[e.code];
    }
});

touchStartX = null;
touchStartY = null;
activeTouch = false;

swipeTarget.addEventListener('touchstart', (e) => {
    e.preventDefault();

    const t = e.touches[0];
    touchStartX = t.clientX;
    touchStartY = t.clientY;
    activeTouch = true;

    pacman.requestedDirection = pacman.direction;
}, { passive: false });

swipeTarget.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (!activeTouch) return;

    const t = e.touches[0];
    const dx = t.clientX - touchStartX;
    const dy = t.clientY - touchStartY;

    if (
        Math.abs(dx) < SWIPE_ACTIVATION_DISTANCE &&
        Math.abs(dy) < SWIPE_ACTIVATION_DISTANCE
    ) return;

    if (Math.abs(dx) > Math.abs(dy)) {
        pacman.requestedDirection = dx > 0 ? 'RIGHT' : 'LEFT';
    } else {
        pacman.requestedDirection = dy > 0 ? 'DOWN' : 'UP';
    }

    touchStartX = t.clientX;
    touchStartY = t.clientY;
}, { passive: false });

swipeTarget.addEventListener('touchend', () => {
    activeTouch = false;
    touchStartX = null;
    touchStartY = null;
});

function isNearTileCenter(entity) {
    const center = getCenterPixel(entity.col, entity.row);
    const dx = Math.abs(entity.x - center.x);
    const dy = Math.abs(entity.y - center.y);

    return (
        dx < TILE_SIZE * TURN_TOLERANCE &&
        dy < TILE_SIZE * TURN_TOLERANCE
    );
}

// --- UPDATE PAC-MAN ---
function updatePacman() {
    const speed = TILE_SIZE * PACMAN_SPEED * speedMultiplier;

    if (
        pacman.requestedDirection !== pacman.direction &&
        canMove(pacman, pacman.requestedDirection) &&
        isNearTileCenter(pacman)
    ) {
        pacman.direction = pacman.requestedDirection;
        setNextTarget(pacman, pacman.direction);
    }

    const arrived = moveEntity(pacman, speed);

    if (MAP[pacman.row][pacman.col] === 0) {
        MAP[pacman.row][pacman.col] = 2;
        score += 10;
    }

    if (arrived && canMove(pacman, pacman.direction)) {
        setNextTarget(pacman, pacman.direction);
    }

    if (pacman.moving) {
        pacman.mouthAngle += pacman.mouthClosing ? -0.04 : 0.04; // was 0.08
        if (pacman.mouthAngle <= 0 || pacman.mouthAngle >= Math.PI / 4) {
            pacman.mouthClosing = !pacman.mouthClosing;
        }
    }
}
// --- DRAW PAC-MAN ---
function drawPacman() {
    // Fade during death
if (deathPhase === 'DYING' || deathPhase === 'RETURNING') {
        ctx.save();
        ctx.globalAlpha = pacmanFade;
    }

    ctx.save();
    ctx.translate(pacman.x, pacman.y);

// --- PAC-MAN GHOST FORM (CELEBRATION) ---
if (pacman.isGhost) {
    // Draw yellow ghost body
    ctx.fillStyle = '#facc15';
    ctx.beginPath();
    ctx.arc(0, 0, pacman.radius, 0, Math.PI * 2);
    ctx.fill();

    // Ghost eyes (same as other ghosts)
    const eyeOffsetX = TILE_SIZE * 0.12;
    const eyeOffsetY = TILE_SIZE * 0.10;
    const eyeRadius   = TILE_SIZE * 0.10;
    const pupilRadius = TILE_SIZE * 0.04;

    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(-eyeOffsetX, -eyeOffsetY, eyeRadius, 0, Math.PI * 2);
    ctx.arc( eyeOffsetX, -eyeOffsetY, eyeRadius, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(-eyeOffsetX, -eyeOffsetY, pupilRadius, 0, Math.PI * 2);
    ctx.arc( eyeOffsetX, -eyeOffsetY, pupilRadius, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore(); // restore the translate()
    if (deathPhase !== 'ALIVE') ctx.restore(); // restore the fade save()
    return; // stop â€” don't draw normal Pac-Man
}

    // ----------------------------------------------------
    // 1. Determine intended direction BEFORE rotation
    // ----------------------------------------------------
    const dir = pacman.requestedDirection || pacman.direction;

    let dx = 0, dy = 0;
    if (dir === 'UP')    dy = -1;
    if (dir === 'DOWN')  dy =  1;
    if (dir === 'LEFT')  dx = -1;
    if (dir === 'RIGHT') dx =  1;

    // ----------------------------------------------------
    // 2. Rotate Pac-Man to match intended direction
    // ----------------------------------------------------
    let rotation = 0;
    if (dir === 'UP')    rotation = -Math.PI / 2;
    if (dir === 'DOWN')  rotation =  Math.PI / 2;
    if (dir === 'LEFT')  rotation =  Math.PI;
    ctx.rotate(rotation);


/* ----------------------------------------------------
   NIGHT LANTERN AURA (based on mouth angle)
   ---------------------------------------------------- */
if (isNight) {

    // Lantern wedge extends Pac-Man's mouth direction
    const glowRadius = pacman.radius * 2.2;   // how far the light reaches
    const glowWidth  = pacman.mouthAngle * 2; // widen the beam

    ctx.save();
    ctx.fillStyle = 'rgba(250, 204, 21, 0.22)';
    ctx.shadowColor = '#facc15';
    ctx.shadowBlur = 25;

    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.arc(0, 0, glowRadius, -glowWidth, glowWidth);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    // Soft shadow behind Pac-Man
    ctx.save();
    ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
    ctx.beginPath();
    ctx.arc(0, 0, pacman.radius * 1.4, Math.PI - glowWidth, Math.PI + glowWidth);
    ctx.fill();
    ctx.restore();
}

    // ----------------------------------------------------
    // 4. Pac-Man body (with pop scale during death)
    // ----------------------------------------------------
    ctx.fillStyle = pacman.color || '#facc15';

    let scale = 1.0;
    if (deathPhase === 'DYING') {
        scale = 1.0 + (1.0 - pacmanFade) * 0.5;
    }

    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.arc(
        0,
        0,
        pacman.radius * scale,
        pacman.mouthAngle,
        Math.PI * 2 - pacman.mouthAngle
    );
    ctx.closePath();
    ctx.fill();

    ctx.restore();

    if (deathPhase !== 'ALIVE') {
        ctx.restore();
    }
}

/* =========================================================
   End of Block 5
   ========================================================= */

/* =========================================================
   Block 5.5 - hlper function for ghost behavior based on distance to hero)
   ========================================================= */

function isGhostInLanternBeam(ghost) {
    if (!isNight) return false;

    // Vector from Pac-Man to ghost
    const dx = ghost.x - pacman.x;
    const dy = ghost.y - pacman.y;
    const dist = Math.hypot(dx, dy);

    if (dist > TILE_SIZE * 6) return false; // beam reach

    // Pac-Man facing direction
    let fx = 0, fy = 0;
    const dir = pacman.requestedDirection || pacman.direction;
    if (dir === 'UP')    fy = -1;
    if (dir === 'DOWN')  fy =  1;
    if (dir === 'LEFT')  fx = -1;
    if (dir === 'RIGHT') fx =  1;

    // Dot product (checks if ghost is in front)
    const dot = dx * fx + dy * fy;
    if (dot <= 0) return false;

    // Angle check (45Â° wedge)
    const angle = Math.acos(dot / (dist * 1));
    if (angle >= Math.PI / 4) return false;

    // --- SAME CORRIDOR CHECK ---
    const pacCol = Math.floor(pacman.x / TILE_SIZE);
    const pacRow = Math.floor(pacman.y / TILE_SIZE);
    const ghostCol = Math.floor(ghost.x / TILE_SIZE);
    const ghostRow = Math.floor(ghost.y / TILE_SIZE);

    // Must share row or column
    const sameRow = pacRow === ghostRow;
    const sameCol = pacCol === ghostCol;

    return sameRow || sameCol;
}


/* =========================================================
   End of BLOCK 5.5
   ========================================================= */

/* =========================================================
   BLOCK 6 â€” GHOSTS (BASELINE AI, NO RENDER HOOKS)
   ========================================================= */

// --- GHOST TARGETING ---
function targetPacman() {
    return { x: pacman.col, y: pacman.row };
}

// --- GHOST PATHFINDING ---
function getGhostDirection(ghost) {
    const target = ghost.targetFn.call(ghost);

    let bestDir = null;
    let bestScore = -Infinity;
    let validMoves = [];

    for (const dir in DIRS) {
        if (!canMove(ghost, dir)) continue;
        validMoves.push(dir);

        const d = DIRS[dir];
        const nextCol = ghost.col + d.x;
        const nextRow = ghost.row + d.y;
        const dist = Math.hypot(target.x - nextCol, target.y - nextRow);

        // Base score: closer = better
        let score = -dist;

        // Avoid lantern beam
        if (isNight) {
            const futureGhost = getCenterPixel(nextCol, nextRow);
            if (isGhostInLanternBeam({ x: futureGhost.x, y: futureGhost.y })) {
                score -= 999;
            }
        }

        if (dir !== oppositeDirection(ghost.direction) && score > bestScore) {
            bestScore = score;
            bestDir = dir;
        }
    }

    if (!bestDir) {
        return validMoves[Math.floor(Math.random() * validMoves.length)];
    }

    return bestDir;
}



// --- INITIALIZE GHOSTS ---
function initializeGhosts() {
    GHOSTS = GHOST_BEHAVIORS.map((behavior) => {
        const g = {
            name: behavior.name,
            color: behavior.color,
            col: GHOST_START_GRID.x,
            row: GHOST_START_GRID.y,
            nextCol: GHOST_START_GRID.x,
            nextRow: GHOST_START_GRID.y,
            x: 0,
            y: 0,
            targetX: 0,
            targetY: 0,
            freezeTimer: 0,
            direction: 'LEFT',
            moving: true,
            targetFn: behavior.targetFn
        };

        const { x, y } = getCenterPixel(g.col, g.row);
        g.x = x;
        g.y = y;

        setNextTarget(g, g.direction);
        return g;
    });
}

function checkGhostCollision() {
    for (const ghost of GHOSTS) {
        const dx = ghost.x - pacman.x;
        const dy = ghost.y - pacman.y;
        const dist = Math.hypot(dx, dy);

        if (dist < TILE_SIZE * 0.5) {
            handlePacmanDeath();
            return;
        }
    }
}

// --- UPDATE GHOST ---
function updateGhost(ghost) {
    const speed = TILE_SIZE * GHOST_SPEED * speedMultiplier;

    // --- FREEZE LOGIC ---
    if (isNight) {
        if (ghost.freezeTimer > 0) {
            ghost.freezeTimer -= 1 / 60; // assuming 60fps
            return; // skip movement entirely
        }

        // If ghost enters lantern beam, freeze briefly
        if (isGhostInLanternBeam(ghost)) {
            ghost.freezeTimer = 0.6; // seconds
            return;
        }
    }

    // --- NORMAL MOVEMENT ---
    const arrived = moveEntity(ghost, speed);

    if (arrived) {
        ghost.direction = getGhostDirection(ghost);
        setNextTarget(ghost, ghost.direction);
    }
}

function drawGhost(ghost) {
    ctx.save();

    // Move to ghost position
    ctx.translate(ghost.x, ghost.y);

    // Apply dance offset (horizontal sway)
    if (ghost.danceOffset) {
        ctx.translate(ghost.danceOffset, 0);
    }

    // Night glow
    if (isNight) {
        const dx = ghost.x - pacman.x;
        const dy = ghost.y - pacman.y;
        const dist = Math.hypot(dx, dy);

        const intensity = Math.max(0, 1 - dist * 0.12);

        ctx.shadowColor = ghost.color;
        ctx.shadowBlur = 12 + intensity * 25;
    } else {
        ctx.shadowBlur = 0;
    }

    // Body
    ctx.fillStyle = ghost.color;
    ctx.beginPath();
    ctx.arc(0, 0, TILE_SIZE * 0.35, 0, Math.PI * 2);
    ctx.fill();

    // Eyes
    const eyeOffsetX = TILE_SIZE * 0.12;
    const eyeOffsetY = TILE_SIZE * 0.10;
    const eyeRadius   = TILE_SIZE * 0.10;
    const pupilRadius = TILE_SIZE * 0.04;

    // White eyes
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(-eyeOffsetX, -eyeOffsetY, eyeRadius, 0, Math.PI * 2);
    ctx.arc( eyeOffsetX, -eyeOffsetY, eyeRadius, 0, Math.PI * 2);
    ctx.fill();

    // Pupils
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(-eyeOffsetX, -eyeOffsetY, pupilRadius, 0, Math.PI * 2);
    ctx.arc( eyeOffsetX, -eyeOffsetY, pupilRadius, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
}



/* =========================================================
   End of Block 6
   ========================================================= */


/* =========================================================
   BLOCK 7 â€” COLOR-BASED GHOST PERSONALITIES
   ========================================================= */

// --- PERSONALITY TARGET FUNCTIONS ---

function targetAmbush() {
    const d = DIRS[pacman.direction];
    return {
        x: pacman.col + d.x * 3,
        y: pacman.row + d.y * 3
    };
}

function targetRandom() {
    return {
        x: Math.floor(Math.random() * MAP_WIDTH),
        y: Math.floor(Math.random() * MAP_HEIGHT)
    };
}

function targetShy() {
    const dist = Math.hypot(
        pacman.col - this.col,
        pacman.row - this.row
    );

    if (dist < 4) {
        return { x: 1, y: MAP_HEIGHT - 2 }; // flee corner
    }
    return { x: pacman.col, y: pacman.row };
}

// --- ASSIGN GHOST BEHAVIORS PER GAME ---
function setupNewGameBehaviors() {
    const PERSONALITIES = {
        red:   targetPacman,
        pink:  targetAmbush,
        cyan:  targetRandom,
        orange: targetShy
    };

    const shuffled = [...GHOST_COLORS].sort(() => Math.random() - 0.5);
    const activeColors = shuffled.slice(0, 2);

    GHOST_BEHAVIORS = activeColors.map((color, index) => ({
        name: `Ghost ${index + 1}`,
        color,
        targetFn: PERSONALITIES[color]
    }));
}

/* =========================================================
   End of Block 7
   ========================================================= */


/* =========================================================
   BLOCK 8 â€” GAME LOOP & ENGINE (AUTHORITATIVE)
   ========================================================= */

// --- UPDATE (AUTHORITATIVE) ---
function update() {
    if (window.gameState  !== 'RUNNING') return;

    if (deathPhase !== 'ALIVE') {
        updateDeathSequence();
        return;
    }

updatePacman();
GHOSTS.forEach(updateGhost);
checkGhostCollision();
updateEndConditions();

}


// --- RENDER (AUTHORITATIVE) ---
function render() {

// --- CELEBRATION: let updateDeathSequence() draw everything ---
if (deathPhase === 'CELEBRATION') {
    // Do NOT clear here; updateDeathSequence handles draw/clear.
    return;
}

    // --- GAME OVER: custom ghost chorus ---
if (window.gameState === 'GAME_OVER') {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const center = getCenterPixel(5, 11);
    const spacing = TILE_SIZE * 1.2;

    // Animate Pac-Ghost rising up
    if (pacGhostJoinProgress < 1) {
        pacGhostJoinProgress += 0.02; // adjust speed if needed
    }

    const joinOffsetY = TILE_SIZE * (1 - pacGhostJoinProgress); // starts below, eases up

    for (let i = 0; i < 5; i++) {
        let ghost;

        const baseY = center.y;

        if (i === 2) {
            // Middle slot â€” Pac-Man ghost
            ghost = {
                x: center.x + (i - 2) * spacing,
                y: baseY + joinOffsetY,
                color: '#facc15',
                danceOffset: Math.sin(frameCounter * 0.2 + i) * TILE_SIZE * 0.3
            };
        } else {
            // Regular ghost
            const color = GHOST_COLORS[(i < 2 ? i : i - 1) % GHOST_COLORS.length];
            ghost = {
                x: center.x + (i - 2) * spacing,
                y: baseY,
                color,
                danceOffset: Math.sin(frameCounter * 0.2 + i) * TILE_SIZE * 0.3
            };
        }

        drawGhost(ghost);
    }

    drawMessage("One of us, One of us!");
    return;
}


    // --- NORMAL RENDER (only when not GAME OVER) ---
if (deathPhase !== 'CELEBRATION') {
    drawMap();
}

    if (isNight) {
        ctx.save();
        ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
    }

// --- NORMAL RENDER (only when not CELEBRATION) ---
if (deathPhase !== 'CELEBRATION') {
    GHOSTS.forEach(drawGhost);

    if (deathPhase !== 'RETURNING') {
        drawPacman();
    }
}

if (deathPhase !== 'CELEBRATION') {
    drawDeathEffects();
}

    if (transitionFlash > 0) {
        ctx.save();
        ctx.fillStyle = `rgba(255,255,255,${transitionFlash})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
        transitionFlash -= 0.05;
    }

    if (window.gameState === 'VICTORY') {
        drawEndScreens();
    }

    if (deathPhase === 'RETURNING') {
        drawMessage(getDeathMessage());
    }
}


// --- GAME LOOP ---
function gameLoop() {
    frameCounter++;
    console.log("Game loop running, frame:", frameCounter);
    update();
    render();
    requestAnimationFrame(gameLoop);
}


// --- RESET / START GAME ---
function resetGame() {
    MAP = JSON.parse(JSON.stringify(INITIAL_MAP));
    score = 0;
    lives = 3;

    pacman.col = 5;
    pacman.row = 11;
    pacman.direction = 'UP';
    pacman.requestedDirection = 'UP';
    pacman.moving = true;
    pacman.isCelebrating = false;

    const { x, y } = getCenterPixel(pacman.col, pacman.row);
    pacman.x = x;
    pacman.y = y;
    pacman.nextCol = pacman.col;
    pacman.nextRow = pacman.row;
    setNextTarget(pacman, pacman.direction);

    setupNewGameBehaviors();
    initializeGhosts();

    window.gameState  = 'RUNNING';
}

// --- BOOTSTRAP ---
resizeCanvas();
resetGame();
gameLoop();

/* =========================================================
   End of Block 8
   ========================================================= */


/* =========================================================
   BLOCK 9 â€” DEATH SEQUENCE & SOUL RETURN (ENGINE-SAFE)
   ========================================================= */

function getDeathMessage() {
    if (typeof lives !== 'number') return "Hmm... something went wrong.";

    if (lives >= 3) {
        return "I'm not done yet!";
    }
    if (lives === 2) {
        return "I'm not done yet!";
    }
    if (lives === 1) {
        return "I'm ... not... done... yet";
    }
    return "...Ok... I'm done";
}

// --- DEATH STATE ---
deathPhase = 'ALIVE'; // ALIVE | DYING | RETURNING | RESPAWNING
deathTimer = 0;

let pacmanFade = 1.0; // 1 = fully visible, 0 = gone

const DEATH_PAUSE_TIME = 40; // frames
const SOUL_RETURN_TIME = 120; // frames

// Soul visual
const soul = {
    x: 0,
    y: 0,
    radius: TILE_SIZE * 0.18
};

// --- PAC-MAN DEATH HANDLER ---
function handlePacmanDeath() {
    pacmanFade = 1.0;
    if (deathPhase !== 'ALIVE') return;

    lives--;
    deathPhase = 'DYING';
    deathTimer = 0;

    pacman.moving = false;
    soul.x = pacman.x;
    soul.y = pacman.y;
}


// --- UPDATE DEATH SEQUENCE ---
function updateDeathSequence() {
    deathTimer++;

    // --- DYING ---
    if (deathPhase === 'DYING') {

        // 1) COLOR SHIMMER (green â†’ blue â†’ green)
        const shimmer = deathTimer % 20;
        if (shimmer < 7) pacman.color = '#22c55e';
        else if (shimmer < 14) pacman.color = '#3b82f6';
        else pacman.color = '#22c55e';

        // 2) POP EFFECT (scale up slightly as he fades)
        pacmanFade -= 0.05;
        if (pacmanFade < 0) pacmanFade = 0;

        if (deathTimer >= DEATH_PAUSE_TIME) {

            pacman.color = '#facc15'; // reset to hero yellow

           // Always go to RETURNING, even on final death
           deathPhase = 'RETURNING';
           deathTimer = 0;
        }

        return;
    }


// --- CELEBRATION (FINAL DEATH ONLY) ---
if (deathPhase === 'CELEBRATION') {

    // Immediately prepare ghosts for the final chorus
    initializeGhosts();

    // Clear Pac-Man's ghost flag so the chorus uses the standard ghost renderer
    pacman.isGhost = false;

    // Jump straight to GAME OVER
    deathPhase = 'ALIVE';
    window.gameState = 'GAME_OVER';

    return;
}



// --- RETURNING ---
if (deathPhase === 'RETURNING') {

    const spawn = getCenterPixel(5, 11);

    // Move soul toward origin
    soul.x += (spawn.x - soul.x) * 0.1;
    soul.y += (spawn.y - soul.y) * 0.1;

    // Check arrival
    const dx = spawn.x - soul.x;
    const dy = spawn.y - soul.y;
    const dist = Math.hypot(dx, dy);

    if (dist < 1) {
        // Soul has arrived â€” start linger timer
        if (!returningPauseStarted) {
            returningPauseStarted = true;
            returningPauseFrames = 0;
            return;
        }

        returningPauseFrames++;

        if (returningPauseFrames >= 60) { // 1 second pause
            if (lives <= 0) {
                deathPhase = 'CELEBRATION';
            } else {
                deathPhase = 'RESPAWNING';
            }
            deathTimer = 0;
            returningPauseStarted = false;
            returningPauseFrames = 0;
        }

        return;
    }

    return;
}


    // --- RESPAWNING ---
    if (deathPhase === 'RESPAWNING') {

        if (lives <= 0) {
            window.gameState = 'GAME_OVER';
            return;
        }

        pacman.isGhost = false;

        pacman.col = 5;
        pacman.row = 11;
        pacman.direction = 'UP';
        pacman.requestedDirection = 'UP';
        pacman.moving = true;

        const { x, y } = getCenterPixel(pacman.col, pacman.row);
        pacman.x = x;
        pacman.y = y;
        pacman.nextCol = pacman.col;
        pacman.nextRow = pacman.row;
        setNextTarget(pacman, pacman.direction);

        initializeGhosts();
        deathPhase = 'ALIVE';
        return;
    }
}


// --- DRAW DEATH EFFECTS ---
function drawDeathEffects() {
if (deathPhase === 'RETURNING' && lives > 0) {
    ctx.save();
    ctx.fillStyle = 'rgba(250, 204, 21, 0.85)'; // soft yellow
    ctx.shadowColor = '#facc15';                // yellow aura
    ctx.shadowBlur = 15;

    ctx.beginPath();
    ctx.arc(soul.x, soul.y, soul.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
}

}

function drawMessage(text) {
    ctx.save();

    // Always bright during celebration or game over
    if (deathPhase === 'CELEBRATION' || window.gameState === 'GAME_OVER' || deathPhase === 'RETURNING') {
        ctx.fillStyle = '#facc15';
        ctx.shadowColor = '#facc15';
        ctx.shadowBlur = 12;
    } else if (lives === 0) {
        ctx.fillStyle = 'rgba(250, 204, 21, 0.4)';
        ctx.shadowColor = 'rgba(250, 204, 21, 0.3)';
        ctx.shadowBlur = 6;
    } else {
        ctx.fillStyle = '#facc15';
        ctx.shadowColor = '#facc15';
        ctx.shadowBlur = 12;
    }

    ctx.font = `${TILE_SIZE * 0.8}px sans-serif`;
    ctx.textAlign = 'center';

    ctx.fillText(
        text,
        canvas.width / 2,
        canvas.height * 0.75
    );

    ctx.restore();
}


/* =========================================================
   End of Block 9
   ========================================================= */


/* =========================================================
   BLOCK 10 â€” VICTORY & GAME OVER (ENGINE-SAFE)
   ========================================================= */

function checkVictory() {
    for (row = 0; row < MAP.length; row++) {
        for (col = 0; col < MAP[row].length; col++) {
            if (MAP[row][col] === 0) return false;
        }
    }
    return true;
}

function drawEndScreens() {
    if (window.gameState === 'VICTORY') {
        drawOverlay("YOU WIN ðŸŽ‰");
    }

    if (window.gameState === 'GAME_OVER') {
    drawOverlay("One of us,One of us!");
    }
}


// --- UPDATE HOOK ---
function updateEndConditions() {
    if (deathPhase !== 'ALIVE') return;

    if (checkVictory()) {
        window.gameState  = 'VICTORY';
        pacman.moving = false;
    }
}

// --- DRAW END SCREENS ---
if (window.gameState === 'VICTORY') {
    drawOverlay("YOU WIN ðŸŽ‰");
}

if (window.gameState === 'GAME_OVER') {
    drawOverlay("... ok I'm done ... for now");
}

function drawOverlay(text) {
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#fff';
    ctx.font = `${TILE_SIZE * 1.2}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillText(
        text,
        canvas.width / 2,
        canvas.height / 2
    );
    ctx.restore();
}

/* =========================================================
   End of Block 10
   ========================================================= */



/* =========================================================
   BLOCK 11 â€” DAY / NIGHT MODE (SAFE â€” NO ENGINE HOOKS)
   ========================================================= */


isNight = false;

// durations in ms
const DAY_TIME = 12000;
const NIGHT_TIME = 8000;

// preserve originals
const DAY_WALL_COLOR = wallColor;
const DAY_SPEED = speedMultiplier;

function enterNight() {
    if (isNight) return;   // guard FIRST

transitionFlash = 1.0;

    isNight = true;
    wallColor = '#C00000';
    speedMultiplier = 1.08;

    GHOSTS.forEach(g => {
        g._dayTarget = g.targetFn;
        g.targetFn = targetPacman;
    });
}

function enterDay() {
    if (!isNight) return;  // guard FIRST

transitionFlash = 1.0;
    isNight = false;
    wallColor = DAY_WALL_COLOR;
    speedMultiplier = DAY_SPEED;

    GHOSTS.forEach(g => {
        if (g._dayTarget) {
            g.targetFn = g._dayTarget;
        }
    });
}


// cycle controller (NO update/render override)
function cycleDayNight() {
    if (window.gameState === 'GAME_OVER' || window.gameState === 'VICTORY') return;

    if (isNight) {
        enterDay();
        setTimeout(cycleDayNight, DAY_TIME);
    } else {
        enterNight();
        setTimeout(cycleDayNight, NIGHT_TIME);
    }
}

setTimeout(cycleDayNight, DAY_TIME);


/* =========================================================
   End of Block 11
   ========================================================= */


</Script>
